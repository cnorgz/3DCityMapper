<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tadhg City Simulator</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      overflow: hidden; 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #1a1a2e;
    }
    canvas { display: block; }
    
    #ui {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 100;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .panel {
      background: rgba(15, 15, 35, 0.9);
      border: 1px solid rgba(100, 200, 255, 0.3);
      border-radius: 12px;
      padding: 15px;
      color: #e0e0e0;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    }

    .compact-panel {
      padding: 10px 12px;
    }

    .compact-panel h3 {
      font-size: 12px;
      margin-bottom: 6px;
    }
    
    .panel h3 {
      color: #64c8ff;
      font-size: 14px;
      margin-bottom: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .btn {
      background: linear-gradient(135deg, #2a3a5a, #1a2a4a);
      border: 1px solid rgba(100, 200, 255, 0.4);
      color: #64c8ff;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.3s;
      margin: 3px;
    }

    .btn-compact {
      padding: 6px 10px;
      font-size: 12px;
      border-radius: 6px;
      margin: 2px;
    }

    .btn-mini {
      padding: 3px 6px;
      font-size: 12px;
      line-height: 1;
      min-width: 26px;
      min-height: 22px;
    }

    .editor-mini-row {
      display: flex;
      gap: 6px;
      margin: 4px 0 8px 22px;
    }

    .btn-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px;
    }

    .compact-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-top: 6px;
      font-size: 12px;
      color: #9fb7c9;
    }
    
    .btn:hover {
      background: linear-gradient(135deg, #3a4a7a, #2a3a6a);
      border-color: #64c8ff;
      transform: translateY(-1px);
    }
    
    .btn.active {
      background: linear-gradient(135deg, #64c8ff, #4488cc);
      color: #0a0a1a;
    }
    
    #info {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 100;
    }
    
    #compass {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 80px;
      height: 80px;
      z-index: 100;
    }
    
    #overlayControls {
      position: fixed;
      top: 20px;
      right: 110px;
      z-index: 100;
    }
    
    #overlayControls .panel {
      width: 320px;
      max-height: calc(100vh - 40px);
      overflow: hidden;
    }

    #overlayControls .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
    }

    #overlayControls .panel-body {
      overflow-y: auto;
      max-height: calc(100vh - 110px);
      padding-right: 6px;
    }

    #overlayControls.collapsed .panel-body {
      display: none;
    }

    #overlayControls .collapse-btn {
      background: rgba(15, 15, 35, 0.9);
      border: 1px solid rgba(100, 200, 255, 0.3);
      color: #64c8ff;
      padding: 4px 8px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
    }

    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(5, 8, 20, 0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 300;
    }

    .modal {
      width: min(520px, 92vw);
      max-height: 80vh;
      overflow: auto;
      background: rgba(15, 15, 35, 0.95);
      border: 1px solid rgba(100, 200, 255, 0.3);
      border-radius: 12px;
      padding: 16px 18px;
      color: #e0e0e0;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
    }

    .modal h3 {
      color: #64c8ff;
      font-size: 14px;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .modal ol {
      padding-left: 18px;
      font-size: 13px;
      line-height: 1.5;
    }

    .modal ul {
      padding-left: 18px;
      font-size: 13px;
      line-height: 1.5;
    }

    .modal .btn {
      margin-top: 10px;
    }
    
    #overlayControls .toggle-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      font-size: 12px;
      color: #e0e0e0;
    }
    
    #overlayControls .control-row {
      display: grid;
      grid-template-columns: 80px 1fr 70px;
      gap: 8px;
      align-items: center;
      margin-bottom: 8px;
      font-size: 12px;
      color: #e0e0e0;
    }
    
    #overlayControls input[type="checkbox"] {
      width: 16px;
      height: 16px;
      cursor: pointer;
    }
    
    #overlayControls input[type="range"] {
      width: 100%;
      margin: 0;
    }
    
    #overlayControls input[type="number"] {
      width: 100%;
      padding: 4px 6px;
      border-radius: 6px;
      border: 1px solid rgba(100, 200, 255, 0.3);
      background: rgba(15, 15, 35, 0.8);
      color: #e0e0e0;
      font-size: 12px;
    }

    #overlayControls select {
      width: 100%;
      padding: 4px 6px;
      border-radius: 6px;
      border: 1px solid rgba(100, 200, 255, 0.3);
      background: rgba(15, 15, 35, 0.95);
      color: #e0e0e0;
      font-size: 12px;
    }
    
    #overlayControls textarea {
      width: 100%;
      min-height: 64px;
      margin-top: 8px;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid rgba(100, 200, 255, 0.3);
      background: rgba(15, 15, 35, 0.8);
      color: #e0e0e0;
      font-size: 11px;
      resize: vertical;
    }
    
    #overlayControls .overlay-help {
      font-size: 11px;
      color: #9fb7c9;
      margin: 6px 0 4px 0;
    }
    
    #overlayControls .overlay-actions {
      display: flex;
      gap: 5px;
      margin-top: 6px;
    }
    
    .loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #1a1a2e;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      flex-direction: column;
      gap: 20px;
    }
    
    .loading h1 {
      color: #64c8ff;
      font-size: 32px;
      letter-spacing: 4px;
    }
    
    .loading-bar {
      width: 200px;
      height: 4px;
      background: rgba(100, 200, 255, 0.2);
      border-radius: 2px;
      overflow: hidden;
    }
    
    .loading-bar-inner {
      width: 0%;
      height: 100%;
      background: linear-gradient(90deg, #64c8ff, #88ddff);
      transition: width 0.3s;
    }
    
    /* Menu toggle */
    #ui.hidden .panel { display: none; }
    #ui.hidden #menuToggle { display: block; }
    
    #menuToggle {
      background: rgba(15, 15, 35, 0.9);
      border: 1px solid rgba(100, 200, 255, 0.4);
      color: #64c8ff;
      padding: 10px 14px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 18px;
    }
    
    /* Touch controls - Virtual Joystick */
    #touchControls {
      position: fixed;
      bottom: 30px;
      right: 30px;
      z-index: 100;
      display: none;
    }
    
    .joystick-container {
      width: 120px;
      height: 120px;
      background: rgba(15, 15, 35, 0.7);
      border: 2px solid rgba(100, 200, 255, 0.4);
      border-radius: 50%;
      position: relative;
      touch-action: none;
    }
    
    .joystick-knob {
      width: 50px;
      height: 50px;
      background: radial-gradient(circle, #64c8ff, #3388aa);
      border-radius: 50%;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      cursor: grab;
      touch-action: none;
    }
    
    #zoomControls {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
      display: none;
      gap: 10px;
    }
    
    .zoom-btn {
      width: 50px;
      height: 50px;
      background: rgba(15, 15, 35, 0.9);
      border: 2px solid rgba(100, 200, 255, 0.4);
      border-radius: 50%;
      color: #64c8ff;
      font-size: 24px;
      cursor: pointer;
    }
    
    /* Show touch controls on touch devices */
    @media (pointer: coarse) {
      #touchControls { display: block; }
      #zoomControls { display: none; } /* disable +/‚àí on mobile */
    }
  </style>
</head>
<body>
  <div class="loading" id="loading">
    <h1>TADHG CITY</h1>
    <div class="loading-bar">
      <div class="loading-bar-inner" id="loadingBar"></div>
    </div>
  </div>
  
  <div id="ui">
    <button id="menuToggle" onclick="toggleMenu()">‚ò∞</button>
    <div class="panel compact-panel">
      <h3>View Mode</h3>
      <div class="btn-grid">
        <button class="btn btn-compact active" id="btnPlan" title="Plan View">Plan</button>
        <button class="btn btn-compact" id="btn3D" title="3D View">3D</button>
        <button class="btn btn-compact" id="btnStreet" title="Street View">St</button>
        <button class="btn btn-compact" id="btnFidelity" title="Fidelity Mode">Fid</button>
      </div>
    </div>
    <div class="panel compact-panel">
      <h3>Time</h3>
      <div class="btn-grid">
        <button class="btn btn-compact active" id="btnDay">Day</button>
        <button class="btn btn-compact" id="btnNight">Night</button>
      </div>
      <div class="compact-row">
        <span>Anim</span>
        <button class="btn btn-compact active" id="btnAnim">On</button>
      </div>
    </div>
    <div class="panel compact-panel">
      <button class="btn btn-compact" id="btnHideUI">Hide Menu</button>
    </div>
    <div class="panel compact-panel">
      <button class="btn btn-compact" id="btnFidelityHelp">Fidelity Steps</button>
      <button class="btn btn-compact" id="btnEditorHelp" style="margin-top: 6px;">Editor Controls</button>
    </div>
  </div>
  
  <div id="info" class="panel">
    <span id="zoneInfo">Hover over zones for info</span>
  </div>
  
  <canvas id="compass"></canvas>
  
  <!-- Map Overlay Controls -->
  <div id="overlayControls" class="panel">
    <div class="panel-header">
      <h3>Map Overlay</h3>
      <button class="collapse-btn" id="overlayPanelToggle">Hide</button>
    </div>
    <div class="panel-body" id="overlayPanelBody">
    <label class="toggle-row">
      <input type="checkbox" id="overlayToggle" />
      <span>Overlay</span>
    </label>
    <div class="control-row">
      <label for="overlayOpacity">Opacity</label>
      <input type="range" id="overlayOpacity" min="0" max="1" step="0.01" value="0.9" data-step="0.01" data-step-fine="0.001" />
      <input type="number" id="overlayOpacityValue" min="0" max="1" step="0.01" value="0.9" />
    </div>
    <hr style="border: none; border-top: 1px solid rgba(100, 200, 255, 0.2); margin: 10px 0;" />
    <h4 style="color: #64c8ff; font-size: 12px; margin: 8px 0 4px 0;">Calibration</h4>
    <div class="control-row">
      <label for="overlayOffsetX">Offset X</label>
      <input type="range" id="overlayOffsetX" min="-400" max="400" step="1" value="0" data-step="1" data-step-fine="0.1" />
      <input type="number" id="overlayOffsetXValue" min="-400" max="400" step="0.1" value="0" />
    </div>
    <div class="control-row">
      <label for="overlayOffsetZ">Offset Z</label>
      <input type="range" id="overlayOffsetZ" min="-400" max="400" step="1" value="0" data-step="1" data-step-fine="0.1" />
      <input type="number" id="overlayOffsetZValue" min="-400" max="400" step="0.1" value="0" />
    </div>
    <div class="control-row">
      <label for="overlayRotation">Rotation</label>
      <input type="range" id="overlayRotation" min="-45" max="45" step="0.1" value="0" data-step="0.1" data-step-fine="0.01" />
      <input type="number" id="overlayRotationValue" min="-45" max="45" step="0.1" value="0" />
    </div>
    <div class="control-row">
      <label for="overlayScale">Scale</label>
      <input type="range" id="overlayScale" min="0.5" max="1.5" step="0.001" value="1" data-step="0.001" data-step-fine="0.0001" />
      <input type="number" id="overlayScaleValue" min="0.5" max="1.5" step="0.001" value="1" />
    </div>
    <div class="overlay-help">Hold Shift for fine steps.</div>
    <div class="overlay-actions">
      <button class="btn" id="overlayReset" style="flex: 1; padding: 6px;">Reset</button>
      <button class="btn" id="overlayExport" style="flex: 1; padding: 6px;">Export</button>
      <button class="btn" id="overlayImport" style="flex: 1; padding: 6px;">Import</button>
    </div>
    <textarea id="overlayJson" placeholder="Paste calibration JSON here"></textarea>
    <hr style="border: none; border-top: 1px solid rgba(100, 200, 255, 0.2); margin: 10px 0;" />
    <h4 style="color: #64c8ff; font-size: 12px; margin: 8px 0 4px 0;">Debug</h4>
    <div class="control-row">
      <label for="overlayDimmer">Map Dim</label>
      <input type="range" id="overlayDimmer" min="0" max="0.8" step="0.01" value="0" data-step="0.01" data-step-fine="0.005" />
      <input type="number" id="overlayDimmerValue" min="0" max="0.8" step="0.01" value="0" />
    </div>
    <label class="toggle-row">
      <input type="checkbox" id="debugGrid" />
      <span>Grid</span>
    </label>
    <label class="toggle-row">
      <input type="checkbox" id="debugOverlayBounds" />
      <span>Overlay Bounds</span>
    </label>
    <label class="toggle-row">
      <input type="checkbox" id="debugBlueprintOutlines" />
      <span>Blueprint Outlines</span>
    </label>
    <label class="toggle-row">
      <input type="checkbox" id="debugRoadCenterlines" />
      <span>Road Centerline</span>
    </label>
    <hr style="border: none; border-top: 1px solid rgba(100, 200, 255, 0.2); margin: 10px 0;" />
    <h4 style="color: #64c8ff; font-size: 12px; margin: 8px 0 4px 0;">Blueprint</h4>
    <div class="control-row">
      <label for="blueprintOpacity">Blueprint Opacity</label>
      <input type="range" id="blueprintOpacity" min="0.1" max="1" step="0.01" value="1" data-step="0.01" data-step-fine="0.01" />
      <input type="number" id="blueprintOpacityValue" min="0.1" max="1" step="0.01" value="1" />
    </div>
    <label class="toggle-row">
      <input type="checkbox" id="blueprintLabels" />
      <span>Polygon Labels</span>
    </label>
    <label class="toggle-row">
      <input type="checkbox" id="blueprintUseCity" />
      <span>Use Blueprint for City</span>
    </label>
    <div class="overlay-actions">
      <button class="btn" id="blueprintLoad" style="flex: 1; padding: 6px;">Load JSON</button>
      <button class="btn" id="blueprintSave" style="flex: 1; padding: 6px;">Save JSON</button>
    </div>
    <div class="overlay-actions">
      <button class="btn" id="blueprintCopy" style="flex: 1; padding: 6px;">Copy JSON</button>
      <button class="btn" id="blueprintValidate" style="flex: 1; padding: 6px;">Validate</button>
    </div>
    <div class="overlay-actions">
      <button class="btn" id="overlayUpload" style="flex: 1; padding: 6px;">Upload Map</button>
    </div>
    <textarea id="blueprintJson" placeholder="Paste blueprint JSON here"></textarea>
    <div id="blueprintStatus" class="overlay-help">Blueprint status: loaded from file.</div>
    <hr style="border: none; border-top: 1px solid rgba(100, 200, 255, 0.2); margin: 10px 0;" />
    <h4 style="color: #64c8ff; font-size: 12px; margin: 8px 0 4px 0;">Editor</h4>
    <label class="toggle-row">
      <input type="checkbox" id="editorEnable" />
      <span>Enable Editor (Fidelity Mode)</span>
    </label>
    <div class="editor-mini-row">
      <button class="btn btn-compact btn-mini" id="editorUndo" title="Undo">&#8630;</button>
      <button class="btn btn-compact btn-mini" id="editorRedo" title="Redo">&#8631;</button>
    </div>
    <div class="control-row">
      <label for="editorTool">Tool</label>
      <select id="editorTool">
        <option value="select">Select</option>
        <option value="polygon">Draw Polygon</option>
        <option value="polyline">Draw Line</option>
        <option value="poi">Add POI</option>
      </select>
      <span></span>
    </div>
    <div class="control-row">
      <label for="editorLayer">Layer</label>
      <select id="editorLayer">
        <option value="buildings">Buildings</option>
        <option value="zones">Zones</option>
        <option value="roads">Roads</option>
        <option value="coastlines">Coastlines</option>
        <option value="beaches">Beaches</option>
        <option value="sea">Sea</option>
      </select>
      <select id="editorTypeCode">
        <option value="Q">Q</option>
        <option value="B">B</option>
        <option value="ZC">ZC</option>
        <option value="J">J</option>
        <option value="H">H</option>
        <option value="R">R</option>
        <option value="PO">PO</option>
        <option value="PK">PK</option>
        <option value="MA">MA</option>
        <option value="H‚òÖ">H‚òÖ</option>
        <option value="S">S</option>
        <option value="T">T</option>
        <option value="D">D</option>
        <option value="Ci">Ci</option>
        <option value="ff">ff</option>
        <option value="P">P</option>
        <option value="‚ö°">‚ö°</option>
        <option value="üíß">üíß</option>
      </select>
    </div>
    <div class="control-row">
      <label for="editorHeightRange">Height (m)</label>
      <input type="range" id="editorHeightRange" min="0" max="2000" step="1" value="0" />
      <input type="number" id="editorHeightValue" min="0" max="2000" step="1" value="0" />
    </div>
    <div class="overlay-actions">
      <button class="btn" id="editorHeightApply" style="flex: 1; padding: 6px;">Apply Height</button>
    </div>
    <div class="control-row">
      <label for="editorTransitType">Line Type</label>
      <select id="editorTransitType">
        <option value="ROAD_MAJOR">ROAD MAJOR</option>
        <option value="ROAD_MINOR">ROAD MINOR</option>
        <option value="PATH">PATH</option>
        <option value="METRO">METRO</option>
        <option value="TRAIN">TRAIN</option>
        <option value="HYPERLOOP">HYPERLOOP</option>
      </select>
      <span></span>
    </div>
    <label class="toggle-row">
      <input type="checkbox" id="editorJunctionMode" />
      <span>Insert Junction</span>
    </label>
    <label class="toggle-row">
      <input type="checkbox" id="editorJunctionAutoSplit" />
      <span>Auto-split crossings</span>
    </label>
    <label class="toggle-row">
      <input type="checkbox" id="editorDebugRoadOffsets" />
      <span>Debug: Road Offsets</span>
    </label>
    <div class="control-row">
      <label for="trafficCarCount">Cars</label>
      <input type="range" id="trafficCarCount" min="0" max="40" step="1" value="12" />
      <input type="number" id="trafficCarCountValue" min="0" max="40" step="1" value="12" />
    </div>
    <div class="control-row">
      <label for="trafficSpeed">Car Speed</label>
      <input type="range" id="trafficSpeed" min="0.2" max="3" step="0.1" value="1" />
      <input type="number" id="trafficSpeedValue" min="0.2" max="3" step="0.1" value="1" />
    </div>
    <div class="control-row">
      <label for="editorPoiType">POI Type</label>
      <select id="editorPoiType">
        <option value="METRO_STATION">METRO</option>
        <option value="TRAIN_STATION">TRAIN</option>
        <option value="HYPERLOOP_NODE">HYPERLOOP</option>
        <option value="PORT">PORT</option>
        <option value="WIND_TURBINE">WIND</option>
        <option value="ECOLE">ECOLE</option>
        <option value="SKYSCRAPER">SKY</option>
        <option value="TRAFFIC_LIGHT">LIGHT</option>
      </select>
      <span></span>
    </div>
    <label class="toggle-row">
      <input type="checkbox" id="editorSnapGrid" />
      <span>Snap to Grid</span>
    </label>
    <label class="toggle-row">
      <input type="checkbox" id="editorSnapPixels" />
      <span>Snap to Pixels</span>
    </label>
    <div class="control-row">
      <label for="editorPixelStep">Pixel Step</label>
      <input type="number" id="editorPixelStep" min="1" step="1" value="10" />
      <span></span>
    </div>
    <div class="control-row">
      <label for="editorZoom">Map Zoom</label>
      <input type="range" id="editorZoom" min="0.5" max="3" step="0.05" value="1" />
      <input type="number" id="editorZoomValue" min="0.5" max="3" step="0.05" value="1" />
    </div>
    <div class="control-row">
      <label for="editorHandleScale">Point Size</label>
      <input type="range" id="editorHandleScale" min="0.4" max="2.5" step="0.05" value="1" />
      <input type="number" id="editorHandleScaleValue" min="0.4" max="2.5" step="0.05" value="1" />
    </div>
    <div class="overlay-actions">
      <button class="btn" id="editorDelete" style="flex: 1; padding: 6px;">Delete</button>
      <button class="btn" id="editorClear" style="flex: 1; padding: 6px;">Clear All</button>
    </div>
    <label class="toggle-row">
      <input type="checkbox" id="editorHideCity" />
      <span>Hide City Geometry</span>
    </label>
    <div id="editorStatus" class="overlay-help">Editor idle.</div>
    </div>
  </div>
  
  <!-- Touch Controls -->
  <div id="touchControls">
    <div class="joystick-container" id="joystick">
      <div class="joystick-knob" id="joystickKnob"></div>
    </div>
  </div>
  
  <div id="zoomControls">
    <button class="zoom-btn" id="zoomIn">+</button>
    <button class="zoom-btn" id="zoomOut">‚àí</button>
  </div>

  <div class="modal-overlay" id="fidelityModal">
    <div class="modal">
      <h3>Fidelity Trace Steps</h3>
      <ol>
        <li>Turn on Overlay and calibrate Offset X/Z, Rotation, and Scale.</li>
        <li>Switch to Fidelity Mode and enable the Editor.</li>
        <li>Trace Coastlines (mainland + island) first.</li>
        <li>Trace Roads next (tarmac shapes as polygons).</li>
        <li>Trace Zones and Buildings using legend codes.</li>
        <li>Add POIs (metro, train, port, turbines, school).</li>
        <li>Toggle Blueprint Outlines to verify alignment.</li>
        <li>Save/Copy the Blueprint JSON for backup.</li>
        <li>Enable ‚ÄúUse Blueprint for City‚Äù to view generated 3D.</li>
      </ol>
      <button class="btn" id="closeFidelityHelp">Close</button>
    </div>
  </div>

  <div class="modal-overlay" id="editorHelpModal">
    <div class="modal">
      <h3>Editor Controls</h3>
      <ul>
        <li>Draw Polygon/Line: click or tap to place points.</li>
        <li>Drag a point to move it (draft or selected shapes).</li>
        <li>Enter: finish polygon/line. Esc: cancel draft.</li>
        <li>Delete/Backspace: remove hovered draft point or current selection.</li>
        <li>Select tool: click a shape to edit vertices or drag the shape.</li>
        <li>Roads: enable ‚ÄúInsert Junction‚Äù then tap an edge to add a junction.</li>
        <li>Auto-split crossings: splits other roads that cross a new junction point.</li>
        <li>Roads: double-click a vertex in Select mode to toggle a curve.</li>
        <li>Pan map when zoomed (drag); use two fingers on touch.</li>
      </ul>
      <button class="btn" id="closeEditorHelp">Close</button>
    </div>
  </div>
  
  <script>
    function toggleMenu() {
      document.getElementById('ui').classList.toggle('hidden');
    }
  </script>
  
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
      }
    }
  </script>
  
  <script type="module">
    import * as THREE from 'three';
    import { Line2 } from 'three/addons/lines/Line2.js';
    import { LineGeometry } from 'three/addons/lines/LineGeometry.js';
    import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
    import { MapCoordMapper, createMapOverlay } from './src/mapOverlay.js';
    import { createOverlayLayer } from './src/overlay/OverlayLayer.js';
    import {
      MAP_WIDTH,
      MAP_HEIGHT,
      MAP_OVERLAY_IMG_W,
      MAP_OVERLAY_IMG_H,
      MAP_OVERLAY_WORLD_W,
      MAP_OVERLAY_WORLD_H,
      GRID_STEP_X,
      GRID_STEP_Z,
      IS_DEV,
      Y,
      OVERLAY_DEFAULTS,
      OVERLAY_LIMITS,
      LINE_TYPES,
      TRANSIT_TYPES,
      USE_RIBBON_ROADS
    } from './src/config/constants.js';
    import {
      COLORS,
      POI_COLORS,
      ROAD_LINE_STYLES,
      TRANSIT_STYLES
    } from './src/config/palette.js';
    import {
      LEGEND_LINE_COLORS,
      LEGEND_TYPE_MAP,
      ALLOWED_TYPE_CODES
    } from './src/config/legendRules.js';
    import { RENDER_FPS } from './src/config/renderPresets.js';
    import { clampNumber, rng } from './src/utils/Math.js';
    import { pointInPolygon, centroidNorm, distancePointToSegment } from './src/utils/GeometryMath.js';
    import { disposeObject3D } from './src/utils/Dispose.js';
    import { getItem, setItem } from './src/persistence/StateStore.js';
    import { runMigrations } from './src/persistence/Migrations.js';
    import { validateBlueprint as validateBlueprintCore } from './src/core/BlueprintValidator.js';
    import { normalizeBlueprint } from './src/core/BlueprintNormalizer.js';
    import { BlueprintModel } from './src/core/BlueprintModel.js';
    import { pixelToOverlayLocal, overlayLocalToPixel } from './src/core/CoordinateMapper.js';
    import {
      loadFromStore as loadOverlayImageFromStore,
      getDataURL as getOverlayImageDataURL,
      getImageId as getOverlayImageId,
      getImageMeta as getOverlayImageMeta,
      setFromFile as setOverlayImageFromFile
    } from './src/scanner/ImageSource.js';
    import {
      createBlueprintPreviewGroups,
      buildBlueprintPreview,
      clearBlueprintPreview
    } from './src/render/BlueprintPreviewRenderer.js';
    import { createSceneManager } from './src/render/SceneManager.js';
    import { createLayerManager } from './src/render/LayerManager.js';
    import { createViewModeController } from './src/render/ViewModeController.js';
    import { createRenderLoop } from './src/render/RenderLoop.js';
    import { getSharedWindowMaterials, getSharedWindowGeometry } from './src/render/MaterialLibrary.js';
    import { createLegacyTerrain } from './src/render/TerrainLayer.js';
    import { buildLegacyTerrainDefs } from './src/terrain/TerrainGenerator.js';
    import { createZoneMeshes } from './src/render/ZoneLayer.js';
    
    // ============================================
    // CONFIGURATION
    // ============================================
    
    
    // ============================================
    // SCENE SETUP
    // ============================================
const sceneManager = createSceneManager({ container: document.body });
const renderer = sceneManager.renderer;
const scene = sceneManager.scene;
const { orthoCamera, perspCamera, getActiveCamera, setActiveCamera: setSceneActiveCamera } = sceneManager.cameras;
const controls = sceneManager.controls;
const { ambientLight, sunLight, hemisphereLight } = sceneManager.lights;

// ============================================
// LAYERS SYSTEM
// ============================================
const layerManager = createLayerManager(scene);
const { LAYERS, BLUEPRINT_LAYERS, blueprintRootGroup, blueprintTraffic, ensureBlueprintTrafficGroup } = layerManager;

// ============================================
// ZONE REGISTRY
// ============================================
const ZONE_REGISTRY = {}; // name -> { zoneMesh, buildingGroup, props: [] }

// ============================================
// LIGHTING ARRAYS (for efficient day/night switching)
// ============================================
const buildingWindows = []; // Legacy - kept for compatibility but unused
const streetLightBulbs = [];
const headlights = [];
const skyscraperWindows = []; // Legacy - kept for compatibility but unused

// ‚úÖ Instanced window batches (replaces buildingWindows / skyscraperWindows usage)
const buildingWindowBatches = [];   // { lit: InstancedMesh, dark: InstancedMesh }
const skyscraperWindowBatches = []; // { lit: InstancedMesh, dark: InstancedMesh }

// Shared fast window materials (opaque = much cheaper than transparent Physical)
const WINDOW_MATS = getSharedWindowMaterials();

// Shared window geometry (normal buildings)
const WINDOW_GEO = getSharedWindowGeometry();

// Helper: build InstancedMesh from matrices
const _tmpObj = new THREE.Object3D();
function makeInstanced(geo, mat, matrices) {
  const mesh = new THREE.InstancedMesh(geo, mat, matrices.length);
  for (let i = 0; i < matrices.length; i++) mesh.setMatrixAt(i, matrices[i]);
  mesh.instanceMatrix.needsUpdate = true;
  mesh.castShadow = false;
  mesh.receiveShadow = false;
  mesh.userData.isWindowBatch = true;
  return mesh;
}

// Cached scene references (avoid getObjectByName every frame)
let windmillsGroup = null;
let ferrisWheelRef = null;

// Map overlay and coordinate mapper
let mapOverlayGroup = null;
let mapOverlayMesh = null;
let overlayDimmer = null;
let mapCoordMapper = null;
let mapOverlayImgW = MAP_OVERLAY_IMG_W;
let mapOverlayImgH = MAP_OVERLAY_IMG_H;
let overlayLayer = null;
let probeMarker = null;
let overlaySettings = null;
let overlayBounds = null;
let gridHelper = null;
let blueprintData = null;
let blueprintOutlineGroup = null;
let blueprintMeshGroup = null;
let blueprintCenterlineGroup = null;
let blueprintOffsetDebugGroup = null;
let blueprintPreviewGroups = null;
let editorGroup = null;
let editorDraftLine = null;
let editorDraftGlowLine = null;
let editorSelectionLine = null;
let editorSelectionGlowLine = null;
let editorDraftRibbon = null;
let editorSelectionRibbon = null;
let editorVertexGroup = null;
let editorDraftVertexGroup = null;
let editorLineEndpointGroup = null;
let editorJunctionMarkerGroup = null;
const debugSettings = {
  showGrid: false,
  showOverlayBounds: false,
  showBlueprintOutlines: false,
  showRoadCenterlines: false
};

const PERSISTENCE_IMAGE_ID = 'demo';
const PERSIST_KEYS = {
  overlayCalib: `overlayCalib:${PERSISTENCE_IMAGE_ID}`,
  overlayPanelCollapsed: 'ui.overlayPanelCollapsed',
  editorSnapGrid: 'editor.snapGrid',
  editorSnapPixels: 'editor.snapPixels',
  editorPixelStep: 'editor.pixelStep',
  trafficMaxCars: 'traffic.maxCars',
  trafficSpeedScale: 'traffic.speedScale',
  blueprintOpacity: 'blueprint.opacity',
  blueprintShowLabels: 'blueprint.showLabels'
};

  const editorState = {
    enabled: false,
    tool: 'select',
    targetLayer: 'zones',
    typeCode: 'Q',
    poiType: 'METRO_STATION',
    transitType: 'METRO',
    snapGrid: false,
  snapPixels: false,
  pixelStep: 10,
  draft: [],
  previewPoint: null,
  selected: null,
  dragging: null,
  hover: null,
  hoverDraftIndex: null,
  hoverLineEndpoint: null,
  hoverJunction: null,
  lastPointerDown: null,
  hideCity: false,
  mapZoom: 1,
  handleScale: 1,
  junctionMode: false,
  junctionBase: null,
  junctionInsertMode: false,
  junctionAutoSplit: true,
  debugRoadOffsets: false
};

const trafficRuntime = {
  maxCars: 12,
  speedScale: 1
};

const editorHistory = {
  undo: [],
  redo: [],
  limit: 80
};

let blueprintCityEnabled = false;
let blueprintZoneMeshes = [];
  let blueprintLabelGroup = null;
  let editorRebuildRaf = null;

const blueprintPreviewSettings = {
  opacity: 1,
  showLabels: false
};

const panState = {
  active: false,
  pending: false,
  pointerId: null,
  lastX: 0,
  lastY: 0,
  isTouch: false,
  deferredAction: null,
  touchPoints: new Map()
};

function normalizeTypeCode(code) {
  if (!code) return '';
  const trimmed = String(code).trim();
  if (!trimmed) return '';
  if (trimmed === '‚ö°' || trimmed === 'üíß') return trimmed;
  const upper = trimmed.toUpperCase();
  if (upper === 'H*' || upper === 'H‚òÖ' || upper === 'HSTAR') return 'H‚òÖ';
  if (upper === 'CI') return 'Ci';
  if (upper === 'FF') return 'ff';
  if (upper === 'ZC') return 'ZC';
  if (upper === 'PO') return 'PO';
  if (upper === 'PK') return 'PK';
  if (upper === 'MA') return 'MA';
  if (ALLOWED_TYPE_CODES.has(upper)) return upper;
  return trimmed;
}

function getLegendInfo(code) {
  const normalized = normalizeTypeCode(code);
  return LEGEND_TYPE_MAP[normalized] || {
    label: normalized || 'Unknown',
    type: 'other',
    color: 0xffffff,
    height: 18,
    buildable: true
  };
}

function getEntryHeight(entry) {
  if (!entry) return 0;
  if (Number.isFinite(entry.heightMeters)) return entry.heightMeters;
  if (Number.isFinite(entry.height)) return entry.height;
  const info = getLegendInfo(entry.typeCode);
  return info.height;
}

function normalizeLineType(type) {
  const raw = String(type || '').trim().toUpperCase();
  if (raw === 'FOOTPATH') return 'PATH';
  if (LINE_TYPES.has(raw)) return raw;
  return 'ROAD_MINOR';
}

function getLineKind(entry) {
  if (!entry) return 'ROAD_MINOR';
  return normalizeLineType(entry.kind ?? entry.type);
}

function isTransitKind(kind) {
  return TRANSIT_TYPES.has(normalizeLineType(kind));
}

function isTransitLine(type) {
  return isTransitKind(type);
}

function getRoadLineStyle(type) {
  const normalized = normalizeLineType(type);
  return ROAD_LINE_STYLES[normalized] || ROAD_LINE_STYLES.ROAD_MINOR;
}

const blueprintHelpers = {
  normalizeTypeCode,
  normalizeLineType,
  ALLOWED_TYPE_CODES,
  LINE_TYPES,
  TRANSIT_TYPES
};
const blueprintModel = new BlueprintModel(blueprintHelpers);

function normalizeBlueprintData(data) {
  return normalizeBlueprint(data, blueprintHelpers);
}

function validateBlueprint(data) {
  return validateBlueprintCore(data, blueprintHelpers);
}

    let activeCamera = orthoCamera;
    let viewMode = 'plan';
    const setActiveCamera = (camera) => {
      activeCamera = camera;
      setSceneActiveCamera(camera);
    };

    // ============================================
// HELPER FUNCTIONS
    // ============================================
    
    const probeEnabled = new URLSearchParams(location.search).has('refactorProbe');

    function exposeDebugState() {
      if (window.__CITYSIM__) return;
      window.__CITYSIM__ = {
        get blueprintData() { return blueprintData; },
        get overlay() {
          return {
            group: mapOverlayGroup,
            position: mapOverlayGroup?.position,
            rotationY: mapOverlayGroup?.rotation?.y,
            scale: mapOverlayGroup?.scale
          };
        },
        get editor() { return editorState; }
      };
    }

    function getProbeRefs() {
      return {
        renderer,
        scene,
        blueprintData,
        mapCoordMapper,
        mapOverlayGroup,
        mapOverlayImgW: mapOverlayImgW,
        mapOverlayImgH: mapOverlayImgH,
        overlayPxToWorld,
        overlayWorldToPx,
        renderFps: RENDER_FPS,
        animationEnabled,
        setViewMode,
        getViewMode: () => viewMode,
        snapshotViewMode: () => ({
          viewMode,
          overlayVisible: !!mapOverlayMesh?.visible,
          editorVisible: !!editorGroup?.visible,
          propsVisible: !!LAYERS?.props?.visible,
          fxVisible: !!LAYERS?.fx?.visible,
          blueprintPropsVisible: !!BLUEPRINT_LAYERS?.props?.visible,
          blueprintFxVisible: !!BLUEPRINT_LAYERS?.fx?.visible
        }),
        overlayPreviewGroups: {
          BlueprintOutlines: blueprintOutlineGroup,
          BlueprintMeshes: blueprintMeshGroup,
          BlueprintLabels: blueprintLabelGroup,
          RoadCenterlines: blueprintCenterlineGroup,
          RoadOffsetDebug: blueprintOffsetDebugGroup
        }
      };
    }

    if (probeEnabled) {
      exposeDebugState();
      import('./tools/refactorProbe.js').then(({ buildRefactorProbeJSON }) => {
        window.runRefactorProbe = () => {
          const json = buildRefactorProbeJSON(getProbeRefs());
          console.log(json);
          return json;
        };
      });
    }

    // Coordinate contract: image (0,0) top-left; world (0,0) center; +X right, +Z down.
    function overlayWorldToPx(x, z) {
      if (!overlayLayer) return null;
      return overlayLayer.overlayWorldToPx?.(x, z) ?? null;
    }

    function overlayPxToWorld(px, py, y = 0) {
      if (!overlayLayer) return null;
      return overlayLayer.overlayPxToWorld?.(px, py, y) ?? null;
    }

    function verifyOverlayMapping() {
      if (!overlayLayer) return;
      const drift = overlayLayer.verifyMapping?.();
      if (!drift) return;
      drift.samples.forEach((sample, idx) => {
        if (sample.dx > drift.epsPx || sample.dy > drift.epsPx) {
          console.warn('Overlay mapping drift', { sampleIndex: idx, sample, epsPx: drift.epsPx });
        }
      });
    }

    function resetGroup(group) {
      if (!group) return;
      disposeObject3D(group);
      group.clear();
    }

    function updateDebugVisibility() {
      const allowed = (viewMode === 'plan' || viewMode === 'fidelity');
      if (gridHelper) gridHelper.visible = allowed && debugSettings.showGrid;
      if (overlayBounds) overlayBounds.visible = allowed && debugSettings.showOverlayBounds;
      if (blueprintOutlineGroup) blueprintOutlineGroup.visible = allowed && debugSettings.showBlueprintOutlines;
      if (blueprintMeshGroup) blueprintMeshGroup.visible = allowed && debugSettings.showBlueprintOutlines;
      if (blueprintLabelGroup) {
        blueprintLabelGroup.visible = allowed && blueprintPreviewSettings.showLabels;
      }
      if (blueprintCenterlineGroup) {
        blueprintCenterlineGroup.visible = allowed && debugSettings.showRoadCenterlines;
      }
      if (blueprintOffsetDebugGroup) {
        blueprintOffsetDebugGroup.visible = allowed && editorState.debugRoadOffsets;
      }
    }

    function applyOverlayCalibKey() {
      const imageId = getOverlayImageId() || PERSISTENCE_IMAGE_ID;
      PERSIST_KEYS.overlayCalib = `overlayCalib:${imageId}`;
    }

    function syncBlueprintRootToOverlay() {
      if (!blueprintRootGroup || !mapOverlayGroup) return;
      if (blueprintRootGroup.parent !== mapOverlayGroup) {
        mapOverlayGroup.add(blueprintRootGroup);
      }
      blueprintRootGroup.position.set(0, 0, 0);
      blueprintRootGroup.rotation.set(0, 0, 0);
      blueprintRootGroup.scale.set(1, 1, 1);
      blueprintRootGroup.updateMatrixWorld();
    }


    function setupDebugHelpers() {
      const buildRectGrid = (width, height, stepX, stepZ, color) => {
        const points = [];
        const halfW = width / 2;
        const halfH = height / 2;

        for (let z = -halfH; z <= halfH + 0.001; z += stepZ) {
          points.push(-halfW, 0, z, halfW, 0, z);
        }
        for (let x = -halfW; x <= halfW + 0.001; x += stepX) {
          points.push(x, 0, -halfH, x, 0, halfH);
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
        const material = new THREE.LineBasicMaterial({ color, transparent: true, opacity: 0.5 });
        material.depthTest = false;
        const lines = new THREE.LineSegments(geometry, material);
        lines.renderOrder = 996;
        return lines;
      };

      gridHelper = buildRectGrid(MAP_OVERLAY_WORLD_W, MAP_OVERLAY_WORLD_H, GRID_STEP_X, GRID_STEP_Z, 0x4fd1ff);
      gridHelper.position.y = Y.overlay + 0.02;
      mapOverlayGroup.add(gridHelper);

      const halfW = MAP_OVERLAY_WORLD_W / 2;
      const halfH = MAP_OVERLAY_WORLD_H / 2;
      const boundsPositions = [
        -halfW, 0, -halfH,
        halfW, 0, -halfH,
        halfW, 0, -halfH,
        halfW, 0, halfH,
        halfW, 0, halfH,
        -halfW, 0, halfH,
        -halfW, 0, halfH,
        -halfW, 0, -halfH
      ];
      const boundsGeometry = new LineGeometry();
      boundsGeometry.setPositions(boundsPositions);
      const boundsMaterial = new LineMaterial({
        color: 0xff2f5a,
        linewidth: 3,
        transparent: true,
        opacity: 0.95
      });
      boundsMaterial.depthTest = false;
      overlayBounds = new Line2(boundsGeometry, boundsMaterial);
      overlayBounds.position.y = Y.overlay + 0.03;
      overlayBounds.renderOrder = 999;
      overlayBounds.frustumCulled = false;
      updateLineResolution(overlayBounds);
      mapOverlayGroup.add(overlayBounds);

      blueprintPreviewGroups = createBlueprintPreviewGroups({ THREE, mapOverlayGroup });
      blueprintOutlineGroup = blueprintPreviewGroups.outline;
      blueprintMeshGroup = blueprintPreviewGroups.meshes;
      blueprintLabelGroup = blueprintPreviewGroups.labels;
      blueprintCenterlineGroup = blueprintPreviewGroups.centerlines;
      blueprintOffsetDebugGroup = blueprintPreviewGroups.offsetDebug;
    }

    function setBlueprintStatus(text, ok = true) {
      const el = document.getElementById('blueprintStatus');
      if (!el) return;
      el.textContent = text;
      el.style.color = ok ? '#9fb7c9' : '#ff9aa2';
    }

    async function loadBlueprintData() {
      try {
        const res = await fetch('./src/mapBlueprint.json');
        if (!res.ok) throw new Error(`Failed to load blueprint: ${res.status}`);
        const raw = await res.json();
        const validation = blueprintModel.validate(raw);
        if (!validation.ok) {
          console.warn('Blueprint validation failed:', validation.errors);
          setBlueprintStatus(`Blueprint invalid: ${validation.errors[0]}`, false);
          return;
        }
        blueprintModel.loadFromJSON(raw);
        blueprintData = blueprintModel.getData();
        buildBlueprintFromData(blueprintData);
        rebuildBlueprintCity();
        setBlueprintStatus('Blueprint status: loaded from file.');
      } catch (error) {
        console.warn('Blueprint load failed:', error);
        setBlueprintStatus('Blueprint status: load failed.', false);
      }
    }

    function buildBlueprintFromData(data) {
      buildBlueprintPreview({
        THREE,
        data,
        groups: blueprintPreviewGroups || {
          outline: blueprintOutlineGroup,
          meshes: blueprintMeshGroup,
          labels: blueprintLabelGroup,
          centerlines: blueprintCenterlineGroup,
          offsetDebug: blueprintOffsetDebugGroup
        },
        Y,
        COLORS,
        POI_COLORS,
        LEGEND_LINE_COLORS,
        TRANSIT_STYLES,
        blueprintPreviewSettings,
        editorState,
        ROAD_JOIN_SETTINGS,
        getRenderPolygonPoints,
        getRenderPolylinePoints,
        getLineKind,
        getRoadLineStyle,
        isTransitKind,
        computeOffsetRails,
        normalizeTypeCode,
        centroidNorm,
        updateDebugVisibility,
        resetGroup
      });
    }

    function clearBlueprintCity() {
      Object.values(BLUEPRINT_LAYERS).forEach(group => resetGroup(group));
      blueprintZoneMeshes = [];
      ensureBlueprintTrafficGroup();
    }

    function buildBlueprintCity(data) {
      if (!data) return;
      clearBlueprintCity();
      blueprintTraffic.lights = [];

      const waterMat = new THREE.MeshStandardMaterial({
        color: COLORS.sea,
        roughness: 0.25,
        metalness: 0.4,
        transparent: true,
        opacity: 0.95
      });

      if (Array.isArray(data.sea) && data.sea.length > 0) {
        data.sea.forEach(entry => {
          const points = getRenderPolygonPoints(entry);
          const mesh = createPolygonWorld(points, COLORS.sea, Y.terrainSea, waterMat);
          if (mesh) BLUEPRINT_LAYERS.terrain.add(mesh);
        });
      } else {
        const waterGeo = new THREE.PlaneGeometry(MAP_WIDTH, MAP_HEIGHT);
        waterGeo.rotateX(-Math.PI / 2);
        const water = new THREE.Mesh(waterGeo, waterMat);
        water.position.y = Y.terrainSea;
        water.receiveShadow = false;
        BLUEPRINT_LAYERS.terrain.add(water);
      }

      (data.beaches || []).forEach(entry => {
        const points = getRenderPolygonPoints(entry);
        const mesh = createPolygonWorld(points, COLORS.beach, Y.beach);
        if (mesh) BLUEPRINT_LAYERS.terrain.add(mesh);
      });

      (data.coastlines || []).forEach(entry => {
        const points = getRenderPolygonPoints(entry);
        const mesh = createPolygonWorld(points, COLORS.land, Y.land);
        if (mesh) BLUEPRINT_LAYERS.terrain.add(mesh);
      });

      const roadMat = new THREE.MeshStandardMaterial({
        color: COLORS.road,
        roughness: 0.9,
        metalness: 0.1,
        side: THREE.DoubleSide,
        polygonOffset: true,
        polygonOffsetFactor: -1,
        polygonOffsetUnits: -1
      });
      const roadMatCache = new Map();
      const getRoadMaterial = (color) => {
        if (roadMatCache.has(color)) return roadMatCache.get(color);
        const mat = new THREE.MeshStandardMaterial({
          color,
          roughness: 0.9,
          metalness: 0.1,
          side: THREE.DoubleSide,
          polygonOffset: true,
          polygonOffsetFactor: -1,
          polygonOffsetUnits: -1
        });
        roadMatCache.set(color, mat);
        return mat;
      };
      const junctions = new Map();
      const recordJunction = (point, width, color) => {
        if (!point) return;
        const key = `${Math.round(point[0] * 100)}|${Math.round(point[1] * 100)}`;
        const prev = junctions.get(key);
        if (!prev || width > prev.width) {
          junctions.set(key, { point, width, color });
        }
      };

      (data.roads || []).forEach(entry => {
        if (entry.polygon) {
          const points = getRenderPolygonPoints(entry);
          const mesh = createPolygonWorld(points, COLORS.road, Y.roads, roadMat);
          if (mesh) BLUEPRINT_LAYERS.roads.add(mesh);
        } else if (entry.polyline) {
          const kind = getLineKind(entry);
          const renderPoints = getRenderPolylinePoints(entry);
          if (!renderPoints || renderPoints.length < 2) return;
          const roadPoints = toWorldPolyline(renderPoints, 1);
          if (isTransitKind(kind)) {
            const style = TRANSIT_STYLES[kind] || TRANSIT_STYLES.METRO;
            const tube = createTransitTube(roadPoints, style.radius, style.color);
            if (tube) BLUEPRINT_LAYERS.roads.add(tube);

            if (kind === 'HYPERLOOP') {
              const chain = createHyperloopChain(roadPoints, style.color);
              BLUEPRINT_LAYERS.props.add(chain);
            }

            if (kind === 'METRO') {
              const stations = Array.isArray(entry.stations)
                ? entry.stations
                : (data.pois || [])
                  .filter(poi => poi.type === 'METRO_STATION')
                  .map(poi => poi.position);
              stations.forEach((pos) => {
                if (!pos || pos.length < 2) return;
                const marker = createMetroStationMarker();
                marker.position.set(pos[0], Y.buildings + 4, pos[1]);
                BLUEPRINT_LAYERS.props.add(marker);
              });
            }
            return;
          }

          const style = getRoadLineStyle(kind);
          const width = Number.isFinite(entry.width) ? entry.width : style.width;
          if (USE_RIBBON_ROADS) {
            const ribbonMat = getRoadMaterial(style.color);
            const ribbon = createRibbonRoadMesh(roadPoints, width, ribbonMat, Y.roads + (style.yOffset ?? 0), {
              miterLimit: 2.5
            });
            if (ribbon) BLUEPRINT_LAYERS.roads.add(ribbon);
            if (style.dash) {
              const dashes = createRoadDashesFromPolyline(roadPoints, {
                y: Y.roads + (style.yOffset ?? 0) + 0.02,
                dashColor: 0xdddd44,
                dashLength: 8,
                dashWidth: 1.1,
                spacing: 18
              });
              if (dashes) BLUEPRINT_LAYERS.roads.add(dashes);
            }
          } else {
            const roadGroup = createRoadSegmentsFromPolyline(roadPoints, width, {
              color: style.color,
              yOffset: style.yOffset ?? 0,
              dashes: style.dash
            });
            BLUEPRINT_LAYERS.roads.add(roadGroup);
          }
          if (entry.polyline?.length >= 2) {
            recordJunction(entry.polyline[0], width, style.color);
            recordJunction(entry.polyline[entry.polyline.length - 1], width, style.color);
          }
        }
      });

      if (USE_RIBBON_ROADS && junctions.size > 0) {
        junctions.forEach(({ point, width, color }) => {
          const radius = Math.max(1.5, width * 0.45);
          const geo = new THREE.CircleGeometry(radius, 12);
          geo.rotateX(-Math.PI / 2);
          const mat = getRoadMaterial(color);
          const cap = new THREE.Mesh(geo, mat);
          cap.position.set(point[0], Y.roads + 0.01, point[1]);
          cap.receiveShadow = true;
          BLUEPRINT_LAYERS.roads.add(cap);
        });
      }

      (data.zones || []).forEach(entry => {
        const info = getLegendInfo(entry.typeCode);
        const points = getRenderPolygonPoints(entry);
        const mesh = createPolygonWorld(points, info.color, Y.zones);
        if (!mesh) return;
        mesh.userData = { label: normalizeTypeCode(entry.typeCode), type: info.type };
        BLUEPRINT_LAYERS.zones.add(mesh);
        blueprintZoneMeshes.push(mesh);
      });

      (data.buildings || []).forEach(entry => {
        const info = getLegendInfo(entry.typeCode);
        if (!info.buildable) return;
        const points = getRenderPolygonPoints(entry);
        const height = getEntryHeight(entry);
        const mesh = createBuildingWorld(points, info.color, height, Y.buildings);
        if (mesh) {
          mesh.userData = { label: normalizeTypeCode(entry.typeCode), type: info.type };
          BLUEPRINT_LAYERS.buildings.add(mesh);
        }
      });

      createBlueprintParkTrees(data);

      (data.pois || []).forEach(entry => {
        if (!entry.position || entry.position.length < 2) return;
        const marker = createPoiMarker(entry.type);
        marker.position.set(entry.position[0], Y.buildings + 3, entry.position[1]);
        marker.userData = { type: entry.type };
        BLUEPRINT_LAYERS.props.add(marker);
        if (entry.type === 'TRAFFIC_LIGHT') {
          blueprintTraffic.lights.push({
            position: entry.position,
            marker,
            lightMesh: marker.userData?.lightMesh || null
          });
        }
      });
    }

    function createBlueprintParkTrees(data) {
      const parkZones = (data.zones || []).filter(entry => normalizeTypeCode(entry.typeCode) === 'J');
      if (parkZones.length === 0) return;

      const roadPolys = (data.roads || [])
        .filter(entry => entry.polygon)
        .map(entry => getRenderPolygonPoints(entry));

      const roadLines = (data.roads || [])
        .filter(entry => entry.polyline)
        .map(entry => ({
          points: getRenderPolylinePoints(entry),
          width: Number.isFinite(entry.width) ? entry.width : getRoadLineStyle(entry.type).width
        }))
        .filter(line => line.points && line.points.length >= 2);

      parkZones.forEach(zone => {
        const points = getRenderPolygonPoints(zone);
        if (!points || points.length < 3) return;

        let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
        points.forEach(([x, z]) => {
          minX = Math.min(minX, x);
          maxX = Math.max(maxX, x);
          minZ = Math.min(minZ, z);
          maxZ = Math.max(maxZ, z);
        });

        const area = Math.max(0, (maxX - minX) * (maxZ - minZ));
        const treeCount = Math.min(35, Math.floor(area / 800));
        for (let i = 0; i < treeCount; i++) {
          const x = minX + rng() * (maxX - minX);
          const z = minZ + rng() * (maxZ - minZ);
          if (!pointInPolygon(x, z, points)) continue;

          const inRoadPoly = roadPolys.some(poly => pointInPolygon(x, z, poly));
          if (inRoadPoly) continue;

          const nearRoadLine = roadLines.some(line => {
            for (let j = 0; j < line.points.length - 1; j++) {
              const a = line.points[j];
              const b = line.points[j + 1];
              const res = distancePointToSegment({ x, z }, a, b);
              if (res.dist2 < (line.width * 0.6) * (line.width * 0.6)) return true;
            }
            return false;
          });
          if (nearRoadLine) continue;

          const tree = createTree();
          tree.position.set(x, Y.zones, z);
          tree.scale.setScalar(0.4 + rng() * 0.4);
          BLUEPRINT_LAYERS.props.add(tree);
        }
      });

      if (blueprintCenterlineGroup) {
        const centerlineMat = new THREE.LineBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.55 * blueprintPreviewSettings.opacity
        });
        centerlineMat.depthTest = false;
        (data.roads || []).forEach(entry => {
          const renderPoints = getRenderPolylinePoints(entry);
          if (!renderPoints || renderPoints.length < 2) return;
          if (isTransitKind(getLineKind(entry))) return;
          const pts = renderPoints.map(p => new THREE.Vector3(p[0], Y.overlay + 0.06, p[1]));
          const geometry = new THREE.BufferGeometry().setFromPoints(pts);
          const line = new THREE.Line(geometry, centerlineMat.clone());
          line.renderOrder = 999;
          blueprintCenterlineGroup.add(line);
        });
      }
    }

    function rebuildBlueprintCity() {
      if (!blueprintData) return;
      if (blueprintCityEnabled) {
        buildBlueprintCity(blueprintData);
      }
      rebuildBlueprintTraffic();
      setCityLayerVisibility();
    }

    function setBlueprintCityEnabled(enabled) {
      blueprintCityEnabled = !!enabled;
      const toggle = document.getElementById('blueprintUseCity');
      if (toggle) toggle.checked = blueprintCityEnabled;
      if (blueprintCityEnabled) {
        if (!blueprintData) loadBlueprintData();
        rebuildBlueprintCity();
      }
      setCityLayerVisibility();
    }
    
    // Rebuild a single zone (for editing)
    function rebuildZone(name) {
      const entry = ZONE_REGISTRY[name];
      if (!entry || !entry.buildingGroup) return;
      
      // Remove instanced window batches BEFORE disposing
      entry.buildingGroup.traverse(obj => {
        if (obj.userData?.isWindowBatch) {
          // Remove from batch arrays
          const batchIdx = buildingWindowBatches.findIndex(b => b.lit === obj || b.dark === obj);
          if (batchIdx > -1) buildingWindowBatches.splice(batchIdx, 1);
          const skyscraperIdx = skyscraperWindowBatches.findIndex(b => b.lit === obj || b.dark === obj);
          if (skyscraperIdx > -1) skyscraperWindowBatches.splice(skyscraperIdx, 1);
        }
        // Legacy: remove from old arrays if they exist
        if (obj.userData?.isWindow) {
          const idx = buildingWindows.indexOf(obj);
          if (idx > -1) buildingWindows.splice(idx, 1);
        }
      });
      
      entry.buildingGroup.removeFromParent();
      disposeObject3D(entry.buildingGroup);
      entry.buildingGroup = null;
      
      // Recreate building from zone data
      const data = entry.zoneMesh.userData;
      if (data.type && data.type !== 'garden' && data.type !== 'port' && data.type !== 'stadium' && data.type !== 'skyscraper') {
        const heights = {
          residential: 25, office: 40, commercial: 20, hospital: 35,
          restaurant: 15, police: 20, parking: 5, mairie: 30,
          hotel: 50, transport: 20, cinema: 25, fairground: 10,
          other: 20
        };
        let height = data.height !== undefined ? data.height : (heights[data.type] || 20);
        if (height >= 5) {
          const buildingGroup = createBuildingWithWindows(data.points, data.color, height, data.type);
          buildingGroup.name = entry.zoneMesh.name + '_building';
          buildingGroup.userData = data;
          buildingGroup.position.y = Y.buildings;
          LAYERS.buildings.add(buildingGroup);
          entry.buildingGroup = buildingGroup;
        }
      }
    }
    
    // Convert normalized [0,1] coordinates to world coordinates
    function toWorld(nx, nz) {
      return [(nx - 0.5) * MAP_WIDTH, (0.5 - nz) * MAP_HEIGHT];
    }
    
    function worldCentroid(points) {
      const [nx, nz] = centroidNorm(points);
      return toWorld(nx, nz);
    }
    
    // Create a flat polygon from normalized coordinates
    function createPolygon(points, color, y = 0) {
      const worldPoints = points.map(([nx, nz]) => {
        const [wx, wz] = toWorld(nx, nz);
        // Invert Z when building 2D shapes so they align with toWorld placements
        return new THREE.Vector2(wx, -wz);
      });
      
      const shape = new THREE.Shape(worldPoints);
      const geometry = new THREE.ShapeGeometry(shape);
      geometry.rotateX(-Math.PI / 2);
      
      const material = new THREE.MeshStandardMaterial({ 
        color, 
        side: THREE.DoubleSide,
        roughness: 0.8,
        metalness: 0.1
      });
      
      const mesh = new THREE.Mesh(geometry, material);
  mesh.position.y = y;
  mesh.receiveShadow = true;
  return mesh;
}

    // Create extruded building from polygon
    function createBuilding(points, color, height, y = 0) {
      const worldPoints = points.map(([nx, nz]) => {
        const [wx, wz] = toWorld(nx, nz);
        return new THREE.Vector2(wx, -wz);
      });
      
      const shape = new THREE.Shape(worldPoints);
      const extrudeSettings = {
        steps: 1,
        depth: height,
        bevelEnabled: false
      };
      
      const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
      geometry.rotateX(-Math.PI / 2);
      
      const material = new THREE.MeshStandardMaterial({ 
        color,
        roughness: 0.7,
        metalness: 0.2
      });
      
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.y = y;
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      return mesh;
    }

    function createPolygonWorld(points, color, y = 0, materialOverride = null) {
      const worldPoints = points.map(([x, z]) => new THREE.Vector2(x, -z));
      const shape = new THREE.Shape(worldPoints);
      const geometry = new THREE.ShapeGeometry(shape);
      geometry.rotateX(-Math.PI / 2);
      const material = materialOverride || new THREE.MeshStandardMaterial({
        color,
        side: THREE.DoubleSide,
        roughness: 0.85,
        metalness: 0.1
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.y = y;
      mesh.receiveShadow = true;
      return mesh;
    }

    function createBuildingWorld(points, color, height, y = 0) {
      const worldPoints = points.map(([x, z]) => new THREE.Vector2(x, -z));
      const shape = new THREE.Shape(worldPoints);
      const extrudeSettings = {
        steps: 1,
        depth: height,
        bevelEnabled: false
      };
      const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
      geometry.rotateX(-Math.PI / 2);
      const material = new THREE.MeshStandardMaterial({
        color,
        roughness: 0.7,
        metalness: 0.2
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.y = y;
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      return mesh;
    }

    // Road/transit polylines render in map-space coordinates.
    // Allow per-consumer Z sign so we can flip only the meshes that need it.
    function toWorldPolyline(points, zSign = 1) {
      if (!points || points.length === 0) return [];
      if (zSign === 1) return points;
      return points.map(([x, z]) => [x, z * zSign]);
    }

    function cleanPolylinePoints(points, eps = 0.5, colinearEps = 0.001) {
      if (!points || points.length < 2) return points || [];
      const out = [points[0]];
      for (let i = 1; i < points.length; i++) {
        const prev = out[out.length - 1];
        const p = points[i];
        const dx = p[0] - prev[0];
        const dz = p[1] - prev[1];
        if (dx * dx + dz * dz > eps * eps) out.push(p);
      }
      if (out.length <= 2) return out;
      const trimmed = [out[0]];
      for (let i = 1; i < out.length - 1; i++) {
        const a = out[i - 1];
        const b = out[i];
        const c = out[i + 1];
        const abx = b[0] - a[0];
        const abz = b[1] - a[1];
        const bcx = c[0] - b[0];
        const bcz = c[1] - b[1];
        const abLen = Math.hypot(abx, abz) || 1;
        const bcLen = Math.hypot(bcx, bcz) || 1;
        const abxN = abx / abLen;
        const abzN = abz / abLen;
        const bcxN = bcx / bcLen;
        const bczN = bcz / bcLen;
        const cross = abxN * bczN - abzN * bcxN;
        const dot = abxN * bcxN + abzN * bczN;
        if (Math.abs(cross) < colinearEps && dot > 0.999) continue;
        trimmed.push(b);
      }
      trimmed.push(out[out.length - 1]);
      return trimmed;
    }

    function lineIntersection(p, d, q, e) {
      const denom = d[0] * e[1] - d[1] * e[0];
      if (Math.abs(denom) < 1e-6) return null;
      const t = ((q[0] - p[0]) * e[1] - (q[1] - p[1]) * e[0]) / denom;
      return [p[0] + d[0] * t, p[1] + d[1] * t];
    }

    const ROAD_JOIN_SETTINGS = {
      roundSegments: 5,
      minAngle: Math.PI / 18,
      maxAngle: Math.PI * 0.9
    };

    function computeOffsetRails(points, half, options = {}) {
      const opts = (typeof options === 'number') ? ROAD_JOIN_SETTINGS : { ...ROAD_JOIN_SETTINGS, ...options };
      const pts = cleanPolylinePoints(points);
      if (pts.length < 2) return { left: [], right: [], center: [], joins: [], clean: pts };

      const segs = [];
      for (let i = 0; i < pts.length - 1; i++) {
        const a = pts[i];
        const b = pts[i + 1];
        const dx = b[0] - a[0];
        const dz = b[1] - a[1];
        const len = Math.hypot(dx, dz) || 1;
        const tx = dx / len;
        const tz = dz / len;
        const nx = tz;
        const nz = -tx;
        segs.push({ tx, tz, nx, nz });
      }

      const left = [];
      const right = [];
      const center = [];
      const joins = [];

      const pushPair = (lx, lz, rx, rz, mode = 'ROUND') => {
        if (left.length > 0) {
          const prevL = left[left.length - 1];
          const prevR = right[right.length - 1];
          const dxL = prevL[0] - lx;
          const dzL = prevL[1] - lz;
          const dxR = prevR[0] - rx;
          const dzR = prevR[1] - rz;
          if ((dxL * dxL + dzL * dzL) < 0.0001 && (dxR * dxR + dzR * dzR) < 0.0001) return;
        }
        left.push([lx, lz]);
        right.push([rx, rz]);
        center.push([(lx + rx) * 0.5, (lz + rz) * 0.5]);
        joins.push({ mode });
      };

      const appendArc = (p, n0, n1, turnDir, modeLabel) => {
        const a0 = Math.atan2(n0[1], n0[0]);
        const a1 = Math.atan2(n1[1], n1[0]);
        let delta = a1 - a0;
        while (delta * turnDir < 0) delta += turnDir * Math.PI * 2;
        if (Math.abs(delta) > opts.maxAngle) {
          const lx0 = p[0] + n0[0] * half;
          const lz0 = p[1] + n0[1] * half;
          const rx0 = p[0] - n0[0] * half;
          const rz0 = p[1] - n0[1] * half;
          const lx1 = p[0] + n1[0] * half;
          const lz1 = p[1] + n1[1] * half;
          const rx1 = p[0] - n1[0] * half;
          const rz1 = p[1] - n1[1] * half;
          pushPair(lx0, lz0, rx0, rz0, 'SPLIT');
          pushPair(lx1, lz1, rx1, rz1, 'SPLIT');
          return;
        }
        const steps = Math.max(2, Math.round((Math.abs(delta) / (Math.PI / 2)) * opts.roundSegments));
        for (let s = 0; s <= steps; s++) {
          const t = s / steps;
          const ang = a0 + delta * t;
          const ox = Math.cos(ang);
          const oz = Math.sin(ang);
          const lx = p[0] + ox * half;
          const lz = p[1] + oz * half;
          const rx = p[0] - ox * half;
          const rz = p[1] - oz * half;
          pushPair(lx, lz, rx, rz, modeLabel);
        }
      };

      for (let i = 0; i < pts.length; i++) {
        const p = pts[i];
        if (i === 0) {
          const n = segs[0];
          pushPair(p[0] + n.nx * half, p[1] + n.nz * half, p[0] - n.nx * half, p[1] - n.nz * half, 'CAP');
          continue;
        }
        if (i === pts.length - 1) {
          const n = segs[segs.length - 1];
          pushPair(p[0] + n.nx * half, p[1] + n.nz * half, p[0] - n.nx * half, p[1] - n.nz * half, 'CAP');
          continue;
        }
        const prev = segs[i - 1];
        const next = segs[i];
        const dot = prev.tx * next.tx + prev.tz * next.tz;
        const angle = Math.acos(Math.max(-1, Math.min(1, dot)));
        if (angle < opts.minAngle) {
          const n = next;
          pushPair(p[0] + n.nx * half, p[1] + n.nz * half, p[0] - n.nx * half, p[1] - n.nz * half, 'STRAIGHT');
          continue;
        }
        const cross = prev.tx * next.tz - prev.tz * next.tx;
        const turnDir = cross >= 0 ? 1 : -1;
        appendArc(p, [prev.nx, prev.nz], [next.nx, next.nz], turnDir, 'ROUND');
      }

      return { left, right, center, joins, clean: pts };
    }

    function buildRibbonGeometryFromPolyline(points, width, y = 0, options = {}) {
      if (!points || points.length < 2) return null;
      const half = width / 2;
      // Phase 6 debug checklist:
      // - Diagonal road: ribbon preview + final mesh coincide.
      // - Road centerline toggle sits centered on ribbon.
      // - Endpoint snap junctions show no visible gaps.
      const positions = [];
      const uvs = [];
      const indices = [];
      const joinOpts = { ...ROAD_JOIN_SETTINGS, ...(typeof options === 'object' ? options : {}) };
      const rails = computeOffsetRails(points, half, joinOpts);
      const count = Math.min(rails.left.length, rails.right.length, rails.center.length);
      if (count < 2) return null;
      const segLengths = [];
      let totalLength = 0;
      for (let i = 0; i < count - 1; i++) {
        const [x1, z1] = rails.center[i];
        const [x2, z2] = rails.center[i + 1];
        const len = Math.hypot(x2 - x1, z2 - z1) || 1;
        segLengths.push(len);
        totalLength += len;
      }

      let acc = 0;
      for (let i = 0; i < count; i++) {
        const u = totalLength > 0 ? acc / totalLength : 0;
        const left = rails.left[i];
        const right = rails.right[i];
        positions.push(left[0], y, left[1]);
        positions.push(right[0], y, right[1]);
        uvs.push(u, 0);
        uvs.push(u, 1);
        if (i < count - 1) acc += segLengths[i];
      }

      for (let i = 0; i < count - 1; i++) {
        const a = i * 2;
        const b = i * 2 + 1;
        const c = i * 2 + 2;
        const d = i * 2 + 3;
        // Flip winding so front face points +Y (top-down view).
        indices.push(a, c, b);
        indices.push(b, c, d);
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
      geometry.setIndex(indices);
      geometry.computeVertexNormals();
      return geometry;
    }

    function createRibbonRoadMesh(points, width, material, y, options = {}) {
      const geometry = buildRibbonGeometryFromPolyline(points, width, y, options);
      if (!geometry) return null;
      const mesh = new THREE.Mesh(geometry, material);
      mesh.receiveShadow = true;
      mesh.castShadow = false;
      return mesh;
    }

    window.__TEST_RIBBON__ = (opts = {}) => {
      const angleDeg = Number.isFinite(opts.angleDeg) ? opts.angleDeg : 90;
      const length = Number.isFinite(opts.length) ? opts.length : 40;
      const width = Number.isFinite(opts.width) ? opts.width : 8;
      const rad = (angleDeg * Math.PI) / 180;
      const p0 = [0, 0];
      const p1 = [length, 0];
      const p2 = [length + Math.cos(rad) * length, Math.sin(rad) * length];
      const geom = buildRibbonGeometryFromPolyline([p0, p1, p2], width, 0, {
        roundSegments: ROAD_JOIN_SETTINGS.roundSegments,
        minAngle: ROAD_JOIN_SETTINGS.minAngle,
        maxAngle: ROAD_JOIN_SETTINGS.maxAngle
      });
      if (!geom) return { ok: false, reason: 'no-geometry' };
      const pos = geom.attributes.position.array;
      const idx = geom.index.array;
      let minArea = Infinity;
      for (let i = 0; i < idx.length; i += 3) {
        const ia = idx[i] * 3;
        const ib = idx[i + 1] * 3;
        const ic = idx[i + 2] * 3;
        const ax = pos[ia];
        const az = pos[ia + 2];
        const bx = pos[ib];
        const bz = pos[ib + 2];
        const cx = pos[ic];
        const cz = pos[ic + 2];
        const area = Math.abs((bx - ax) * (cz - az) - (bz - az) * (cx - ax)) * 0.5;
        minArea = Math.min(minArea, area);
      }
      return { ok: minArea > 0.0001, minArea, triangles: idx.length / 3 };
    };

    function createRoadSegmentsFromPolyline(points, width = 12, options = {}) {
      const group = new THREE.Group();
      if (!points || points.length < 2) return group;
      const color = options.color ?? COLORS.road;
      const yOffset = options.yOffset ?? 0;
      const includeDashes = options.dashes !== undefined ? options.dashes : true;
      const dashY = Y.roads + yOffset + 0.16;
      const mat = new THREE.MeshStandardMaterial({
        color,
        roughness: 0.9,
        metalness: 0.1
      });
      for (let i = 0; i < points.length - 1; i++) {
        const [x1, z1] = points[i];
        const [x2, z2] = points[i + 1];
        const dx = x2 - x1;
        const dz = z2 - z1;
        const length = Math.hypot(dx, dz);
        if (length < 0.001) continue;
        const geo = new THREE.BoxGeometry(length, 0.3, width);
        const road = new THREE.Mesh(geo, mat);
        road.position.set((x1 + x2) / 2, Y.roads + yOffset, (z1 + z2) / 2);
        road.rotation.y = Math.atan2(dz, dx);
        road.receiveShadow = true;
        road.material.polygonOffset = true;
        road.material.polygonOffsetFactor = -1;
        road.material.polygonOffsetUnits = -1;
        group.add(road);
      }
      if (includeDashes) {
        const dashes = createRoadDashesFromPolyline(points, {
          y: dashY + 0.02,
          dashColor: 0xdddd44,
          dashLength: 8,
          dashWidth: 1.1,
          spacing: 18
        });
        if (dashes) group.add(dashes);
      }
      return group;
    }

    function createRoadDashesFromPolyline(points, options = {}) {
      if (!points || points.length < 2) return null;
      const spacing = options.spacing ?? 18;
      const dashLength = options.dashLength ?? 8;
      const dashWidth = options.dashWidth ?? 1.1;
      const dashColor = options.dashColor ?? 0xdddd44;
      const y = options.y ?? (Y.roads + 0.35);
      // Dash geometry is oriented along +Z so yaw aligns to centerline via atan2(dx, dz).
      const dashGeo = new THREE.BoxGeometry(dashWidth, 0.12, dashLength);
      const dashMat = new THREE.MeshBasicMaterial({
        color: dashColor,
        depthTest: true,
        depthWrite: false
      });
      dashMat.polygonOffset = true;
      dashMat.polygonOffsetFactor = -2;
      dashMat.polygonOffsetUnits = -2;
      const instances = [];

      for (let i = 0; i < points.length - 1; i++) {
        const [x1, z1] = points[i];
        const [x2, z2] = points[i + 1];
        const dx = x2 - x1;
        const dz = z2 - z1;
        const length = Math.hypot(dx, dz);
        if (length < 0.001) continue;
        const angle = Math.atan2(dx, dz);
        const steps = Math.floor(length / spacing);
        for (let s = 0; s <= steps; s++) {
          const dist = spacing * 0.5 + s * spacing;
          if (dist >= length) break;
          const t = dist / length;
          instances.push({ x: x1 + dx * t, z: z1 + dz * t, angle });
        }
      }

      if (instances.length === 0) return null;
      const mesh = new THREE.InstancedMesh(dashGeo, dashMat, instances.length);
      instances.forEach((item, idx) => {
        _tmpObj.position.set(item.x, y, item.z);
        _tmpObj.rotation.set(0, item.angle, 0);
        _tmpObj.updateMatrix();
        mesh.setMatrixAt(idx, _tmpObj.matrix);
      });
      mesh.instanceMatrix.needsUpdate = true;
      mesh.castShadow = false;
      mesh.receiveShadow = false;
      mesh.renderOrder = 10;
      return mesh;
    }

    // ============================================
    // Phase 6.1 - Blueprint Traffic (prototype)
    // ============================================
    const TRAFFIC_SETTINGS = {
      laneOffsetFactor: 0.25,
      minRoadLength: 80,
      maxCars: 24,
      speedMajor: 45,
      speedMinor: 30,
      yOffset: 1.2,
      smoothSegments: 8,
      lightCycle: 6,
      lightStopRadius: 10
    };

    function buildOffsetPolyline(points, offset, options = {}) {
      if (!points || points.length < 2) return points;
      if (!offset) return points;
      const half = Math.abs(offset);
      const rails = computeOffsetRails(points, half, options);
      if (offset >= 0) return rails.left;
      return rails.right;
    }

    function smoothPolyline(points, iterations = 1, alpha = 0.25) {
      if (!points || points.length < 3) return points;
      let current = points.map(p => [p[0], p[1]]);
      for (let iter = 0; iter < iterations; iter++) {
        const next = [current[0]];
        for (let i = 0; i < current.length - 1; i++) {
          const p0 = current[i];
          const p1 = current[i + 1];
          const q = [p0[0] + (p1[0] - p0[0]) * alpha, p0[1] + (p1[1] - p0[1]) * alpha];
          const r = [p0[0] + (p1[0] - p0[0]) * (1 - alpha), p0[1] + (p1[1] - p0[1]) * (1 - alpha)];
          next.push(q, r);
        }
        next.push(current[current.length - 1]);
        current = next;
      }
      return current;
    }

    function buildPathData(points) {
      if (!points || points.length < 2) return null;
      const lengths = [0];
      let total = 0;
      for (let i = 1; i < points.length; i++) {
        const dx = points[i][0] - points[i - 1][0];
        const dz = points[i][1] - points[i - 1][1];
        total += Math.hypot(dx, dz);
        lengths.push(total);
      }
      const startDx = points[1][0] - points[0][0];
      const startDz = points[1][1] - points[0][1];
      const endDx = points[points.length - 1][0] - points[points.length - 2][0];
      const endDz = points[points.length - 1][1] - points[points.length - 2][1];
      const startLen = Math.hypot(startDx, startDz) || 1;
      const endLen = Math.hypot(endDx, endDz) || 1;
      const forwardStartDir = { x: startDx / startLen, z: startDz / startLen };
      const forwardEndDir = { x: endDx / endLen, z: endDz / endLen };
      const dxEnd = points[0][0] - points[points.length - 1][0];
      const dzEnd = points[0][1] - points[points.length - 1][1];
      const closed = Math.hypot(dxEnd, dzEnd) < 5;
      return { points, lengths, total, closed, forwardStartDir, forwardEndDir };
    }

    function buildRoadGraph(roads) {
      const nodes = [];
      const nodeMap = new Map();
      const eps = 1.5;
      const keyFor = (x, z) => `${Math.round(x / eps)}|${Math.round(z / eps)}`;
      const getNode = (x, z) => {
        const key = keyFor(x, z);
        let node = nodeMap.get(key);
        if (!node) {
          node = { id: nodes.length, x, z, edges: [], key };
          nodeMap.set(key, node);
          nodes.push(node);
        }
        return node;
      };

      (roads || []).forEach((entry) => {
        if (!entry?.polyline || entry.polyline.length < 2) return;
        const kind = getLineKind(entry);
        if (isTransitKind(kind) || kind === 'PATH') return;
        const renderPoints = getRenderPolylinePoints(entry);
        if (!renderPoints || renderPoints.length < 2) return;
        for (let i = 0; i < renderPoints.length - 1; i++) {
          const a = renderPoints[i];
          const b = renderPoints[i + 1];
          const nodeA = getNode(a[0], a[1]);
          const nodeB = getNode(b[0], b[1]);
          nodeA.edges.push({ to: nodeB, kind });
          nodeB.edges.push({ to: nodeA, kind });
        }
      });

      return { nodes };
    }

    function buildRandomWalkPolyline(graph, maxSteps = 10) {
      if (!graph?.nodes || graph.nodes.length === 0) return null;
      let start = graph.nodes[Math.floor(Math.random() * graph.nodes.length)];
      if (!start.edges.length) {
        start = graph.nodes.find(node => node.edges.length > 0);
      }
      if (!start || !start.edges.length) return null;
      const points = [[start.x, start.z]];
      const kinds = [];
      let current = start;
      let prev = null;
      const pickEdge = (node, previous) => {
        const options = node.edges.filter(edge => edge.to !== previous);
        const candidates = options.length ? options : node.edges;
        if (!candidates.length) return null;
        if (!previous || candidates.length === 1) {
          return candidates[Math.floor(Math.random() * candidates.length)];
        }
        const vx = node.x - previous.x;
        const vz = node.z - previous.z;
        const vLen = Math.hypot(vx, vz) || 1;
        const vxn = vx / vLen;
        const vzn = vz / vLen;
        let best = candidates[0];
        let bestScore = Infinity;
        candidates.forEach(edge => {
          const wx = edge.to.x - node.x;
          const wz = edge.to.z - node.z;
          const wLen = Math.hypot(wx, wz) || 1;
          const wxn = wx / wLen;
          const wzn = wz / wLen;
          const cross = vxn * wzn - vzn * wxn;
          const dot = vxn * wxn + vzn * wzn;
          const angle = Math.atan2(cross, dot);
          const score = Math.abs(angle) + (angle > 0 ? 0.25 : 0);
          if (score < bestScore - 0.0001) {
            bestScore = score;
            best = edge;
          } else if (Math.abs(score - bestScore) < 0.0001 && Math.random() < 0.35) {
            best = edge;
          }
        });
        return best;
      };
      for (let step = 0; step < maxSteps; step++) {
        const edge = pickEdge(current, prev);
        if (!edge) break;
        kinds.push(edge.kind);
        prev = current;
        current = edge.to;
        points.push([current.x, current.z]);
      }
      if (points.length < 2) return null;
      const kind = kinds.includes('ROAD_MAJOR') ? 'ROAD_MAJOR' : 'ROAD_MINOR';
      return {
        points,
        kind,
        startKey: start.key,
        endKey: current.key,
        startDegree: start.edges.length,
        endDegree: current.edges.length
      };
    }

    function samplePathAt(path, distance, direction = 1) {
      if (!path || !path.points || path.points.length < 2) return null;
      let dist = distance;
      if (path.closed && path.total > 0) {
        dist = ((dist % path.total) + path.total) % path.total;
      } else {
        dist = Math.max(0, Math.min(path.total, dist));
      }
      let segIndex = 0;
      while (segIndex < path.lengths.length - 2 && path.lengths[segIndex + 1] < dist) {
        segIndex += 1;
      }
      const segStart = path.lengths[segIndex];
      const segEnd = path.lengths[segIndex + 1];
      const segLen = Math.max(0.0001, segEnd - segStart);
      const t = (dist - segStart) / segLen;
      const [x1, z1] = path.points[segIndex];
      const [x2, z2] = path.points[segIndex + 1];
      let dx = x2 - x1;
      let dz = z2 - z1;
      if (direction < 0) {
        dx = -dx;
        dz = -dz;
      }
      const x = x1 + (x2 - x1) * t;
      const z = z1 + (z2 - z1) * t;
      const rotation = Math.atan2(dx, dz) - Math.PI / 2;
      return { x, z, rotation };
    }

    function clearBlueprintTraffic() {
      if (!blueprintTraffic.group) return;
      resetGroup(blueprintTraffic.group);
      blueprintTraffic.cars = [];
      blueprintTraffic.paths = [];
      if (Array.isArray(headlights) && headlights.length > 0) {
        for (let i = headlights.length - 1; i >= 0; i--) {
          if (headlights[i]?.userData?.blueprintTraffic) {
            headlights.splice(i, 1);
          }
        }
      }
    }

    function rebuildBlueprintTraffic() {
      ensureBlueprintTrafficGroup();
      clearBlueprintTraffic();
      if (!blueprintCityEnabled || !blueprintData) return;

      const roads = blueprintData.roads || [];
      const graph = buildRoadGraph(roads);
      const paths = [];
      const maxPaths = Math.min(18, graph.nodes.length * 2);
      let attempts = 0;
      while (paths.length < maxPaths && attempts < maxPaths * 4) {
        attempts += 1;
        const walk = buildRandomWalkPolyline(graph, 10 + Math.floor(Math.random() * 8));
        if (!walk || walk.points.length < 2) continue;
        const kind = walk.kind || 'ROAD_MINOR';
        const style = getRoadLineStyle(kind);
        const width = style.width;
        const laneOffset = Math.max(2.5, width * TRAFFIC_SETTINGS.laneOffsetFactor);
        const left = buildOffsetPolyline(walk.points, laneOffset, ROAD_JOIN_SETTINGS);
        const right = buildOffsetPolyline(walk.points, -laneOffset, ROAD_JOIN_SETTINGS);
        const leftPath = buildPathData(left);
        const rightPath = buildPathData(right);
        if (leftPath && leftPath.total >= TRAFFIC_SETTINGS.minRoadLength) {
          leftPath.kind = kind;
          leftPath.direction = -1;
          leftPath.startKey = walk.endKey;
          leftPath.endKey = walk.startKey;
          leftPath.startDegree = walk.endDegree;
          leftPath.endDegree = walk.startDegree;
          if (leftPath.forwardStartDir && leftPath.forwardEndDir) {
            leftPath.dirAtStart = { x: -leftPath.forwardEndDir.x, z: -leftPath.forwardEndDir.z };
            leftPath.dirAtEnd = { x: -leftPath.forwardStartDir.x, z: -leftPath.forwardStartDir.z };
          }
          paths.push(leftPath);
        }
        if (rightPath && rightPath.total >= TRAFFIC_SETTINGS.minRoadLength) {
          rightPath.kind = kind;
          rightPath.direction = 1;
          rightPath.startKey = walk.startKey;
          rightPath.endKey = walk.endKey;
          rightPath.startDegree = walk.startDegree;
          rightPath.endDegree = walk.endDegree;
          if (rightPath.forwardStartDir && rightPath.forwardEndDir) {
            rightPath.dirAtStart = { x: rightPath.forwardStartDir.x, z: rightPath.forwardStartDir.z };
            rightPath.dirAtEnd = { x: rightPath.forwardEndDir.x, z: rightPath.forwardEndDir.z };
          }
          paths.push(rightPath);
        }
      }

      blueprintTraffic.paths = paths.filter(p => p && p.total >= TRAFFIC_SETTINGS.minRoadLength);
      let spawned = 0;
      const maxCars = Math.max(0, Number.isFinite(trafficRuntime.maxCars) ? trafficRuntime.maxCars : TRAFFIC_SETTINGS.maxCars);
      blueprintTraffic.paths.forEach(path => {
        if (spawned >= maxCars) return;
        const color = COLORS.cars?.[Math.floor(Math.random() * COLORS.cars.length)] ?? 0xff3333;
        const car = createCar(color, { blueprintTraffic: true });
        car.userData.blueprintTraffic = true;
        car.userData.path = path;
        car.userData.distance = Math.random() * path.total;
        car.userData.direction = Number.isFinite(path.direction) ? path.direction : 1;
        const baseSpeed = path.kind === 'ROAD_MAJOR' ? TRAFFIC_SETTINGS.speedMajor : TRAFFIC_SETTINGS.speedMinor;
        car.userData.speed = baseSpeed * (0.7 + Math.random() * 0.6) * trafficRuntime.speedScale;
        const sample = samplePathAt(path, car.userData.distance, car.userData.direction);
        if (sample) {
          car.position.set(sample.x, Y.roads + TRAFFIC_SETTINGS.yOffset, sample.z);
          car.rotation.y = sample.rotation;
        }
        blueprintTraffic.group.add(car);
        blueprintTraffic.cars.push(car);
        spawned += 1;
      });
    }

    function animateBlueprintTraffic(dt) {
      if (!blueprintCityEnabled || blueprintTraffic.cars.length === 0) return;
      const lights = blueprintTraffic.lights || [];
      const time = performance.now() * 0.001;
      const cycle = Math.max(1, TRAFFIC_SETTINGS.lightCycle);
      const phase = Math.floor(time / cycle) % 2;
      const lightIsRed = phase === 0;
      const pickNextPath = (currentPath, targetKey, currentDir) => {
        if (!targetKey) return null;
        const candidates = blueprintTraffic.paths.filter(p => p !== currentPath && p.startKey === targetKey);
        if (candidates.length === 0) return null;
        if (!currentDir) return candidates[Math.floor(Math.random() * candidates.length)];
        let best = null;
        let bestScore = Infinity;
        candidates.forEach((path) => {
          const dir = path.dirAtStart || path.forwardStartDir;
          if (!dir) return;
          const dot = currentDir.x * dir.x + currentDir.z * dir.z;
          if (dot < -0.25) return; // avoid U-turns unless no alternative
          const cross = currentDir.x * dir.z - currentDir.z * dir.x;
          const angle = Math.atan2(cross, dot);
          const score = Math.abs(angle) + (cross > 0 ? 0.2 : 0);
          if (score < bestScore) {
            bestScore = score;
            best = path;
          }
        });
        if (best) return best;
        // fallback if all candidates were U-turns
        return candidates[Math.floor(Math.random() * candidates.length)];
      };
      if (lights.length > 0) {
        lights.forEach((light) => {
          const mesh = light.lightMesh;
          if (!mesh || !mesh.material) return;
          const mat = mesh.material;
          if (lightIsRed) {
            mat.color.setHex(0xff3b3b);
            if (mat.emissive) {
              mat.emissive.setHex(0xff3b3b);
              mat.emissiveIntensity = 0.8;
            }
          } else {
            mat.color.setHex(0x4dff64);
            if (mat.emissive) {
              mat.emissive.setHex(0x4dff64);
              mat.emissiveIntensity = 0.8;
            }
          }
        });
      }
      blueprintTraffic.cars.forEach(car => {
        const path = car.userData.path;
        if (!path || path.total <= 0) return;
        let speedScale = 1;
        if (lightIsRed && lights.length > 0) {
          const stopRadius2 = TRAFFIC_SETTINGS.lightStopRadius * TRAFFIC_SETTINGS.lightStopRadius;
          for (const light of lights) {
            const pos = light.position || [];
            const dx = car.position.x - pos[0];
            const dz = car.position.z - pos[1];
            if ((dx * dx + dz * dz) <= stopRadius2) {
              speedScale = 0;
              break;
            }
          }
        }
        let dist = car.userData.distance + car.userData.speed * dt * speedScale * car.userData.direction;
        if (path.closed) {
          dist = ((dist % path.total) + path.total) % path.total;
        } else {
          if (dist >= path.total) {
            if ((path.endDegree ?? 0) <= 1) {
              dist = path.total;
              car.userData.direction = -1;
            } else {
              const currentDir = path.dirAtEnd || path.forwardEndDir;
              const nextPath = pickNextPath(path, path.endKey, currentDir);
              if (nextPath) {
                car.userData.path = nextPath;
                car.userData.direction = nextPath.direction;
                car.userData.distance = nextPath.direction >= 0 ? 0 : nextPath.total;
                const nextSample = samplePathAt(nextPath, car.userData.distance, car.userData.direction);
                if (nextSample) {
                  car.position.set(nextSample.x, Y.roads + TRAFFIC_SETTINGS.yOffset, nextSample.z);
                  car.rotation.y = nextSample.rotation;
                }
                return;
              }
              dist = 0;
            }
          } else if (dist <= 0) {
            if ((path.startDegree ?? 0) <= 1) {
              dist = 0;
              car.userData.direction = 1;
            } else {
              const currentDir = path.dirAtStart || path.forwardStartDir;
              const nextPath = pickNextPath(path, path.startKey, currentDir);
              if (nextPath) {
                car.userData.path = nextPath;
                car.userData.direction = nextPath.direction;
                car.userData.distance = nextPath.direction >= 0 ? 0 : nextPath.total;
                const nextSample = samplePathAt(nextPath, car.userData.distance, car.userData.direction);
                if (nextSample) {
                  car.position.set(nextSample.x, Y.roads + TRAFFIC_SETTINGS.yOffset, nextSample.z);
                  car.rotation.y = nextSample.rotation;
                }
                return;
              }
              dist = path.total;
            }
          }
        }
        car.userData.distance = dist;
        const sample = samplePathAt(path, dist, car.userData.direction);
        if (!sample) return;
        car.position.set(sample.x, Y.roads + TRAFFIC_SETTINGS.yOffset, sample.z);
        car.rotation.y = sample.rotation;
      });
    }

    function getLaneCenterlines(points, offset = 3) {
      if (!points || points.length < 2) return { left: [], right: [] };
      const left = [];
      const right = [];
      const count = points.length;
      for (let i = 0; i < count; i++) {
        const prev = points[Math.max(0, i - 1)];
        const next = points[Math.min(count - 1, i + 1)];
        const dx = next[0] - prev[0];
        const dz = next[1] - prev[1];
        const len = Math.hypot(dx, dz) || 1;
        const nx = dz / len;
        const nz = -dx / len;
        left.push([points[i][0] + nx * offset, points[i][1] + nz * offset]);
        right.push([points[i][0] - nx * offset, points[i][1] - nz * offset]);
      }
      return { left, right };
    }

    function createTransitTube(points, radius, color) {
      if (!points || points.length < 2) return null;
      const curve = new THREE.CatmullRomCurve3(
        points.map(p => new THREE.Vector3(p[0], Y.roads + 0.6, p[1]))
      );
      const segments = Math.max(20, points.length * 6);
      const geometry = new THREE.TubeGeometry(curve, segments, radius, 8, false);
      const material = new THREE.MeshStandardMaterial({
        color,
        roughness: 0.4,
        metalness: 0.2
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.receiveShadow = true;
      return mesh;
    }

    function createHyperloopChain(points, color) {
      const group = new THREE.Group();
      if (!points || points.length < 2) return group;
      const ringGeo = new THREE.TorusGeometry(3.2, 0.7, 6, 12);
      const ringMat = new THREE.MeshStandardMaterial({ color, roughness: 0.3, metalness: 0.4 });
      const spacing = 28;
      for (let i = 0; i < points.length - 1; i++) {
        const [x1, z1] = points[i];
        const [x2, z2] = points[i + 1];
        const dx = x2 - x1;
        const dz = z2 - z1;
        const length = Math.hypot(dx, dz);
        if (length < 0.001) continue;
        const steps = Math.max(1, Math.floor(length / spacing));
        for (let s = 0; s <= steps; s++) {
          const t = s / steps;
          const x = x1 + dx * t;
          const z = z1 + dz * t;
          const ring = new THREE.Mesh(ringGeo, ringMat);
          ring.position.set(x, Y.roads + 3, z);
          ring.rotation.y = Math.atan2(dz, dx);
          group.add(ring);
        }
      }
      return group;
    }

    function createMetroStationMarker() {
      const size = 64;
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, size, size);
      ctx.beginPath();
      ctx.arc(size / 2, size / 2, size * 0.42, 0, Math.PI * 2);
      ctx.fillStyle = '#2f7bff';
      ctx.fill();
      ctx.lineWidth = 4;
      ctx.strokeStyle = '#ffffff';
      ctx.stroke();
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 28px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('M', size / 2, size / 2 + 2);

      const texture = new THREE.CanvasTexture(canvas);
      texture.colorSpace = THREE.SRGBColorSpace;
      const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
      const sprite = new THREE.Sprite(material);
      sprite.scale.set(18, 18, 1);
      return sprite;
    }

    function createPoiMarker(type) {
      switch (type) {
        case 'METRO_STATION': {
          return createMetroStationMarker();
        }
        case 'TRAIN_STATION': {
          const group = new THREE.Group();
          const base = new THREE.Mesh(
            new THREE.BoxGeometry(12, 6, 10),
            new THREE.MeshStandardMaterial({ color: 0xaaaaaa })
          );
          base.position.y = 3;
          group.add(base);
          const roof = new THREE.Mesh(
            new THREE.BoxGeometry(14, 2, 12),
            new THREE.MeshStandardMaterial({ color: 0x444444 })
          );
          roof.position.y = 7;
          group.add(roof);
          return group;
        }
        case 'HYPERLOOP_NODE': {
          const torus = new THREE.Mesh(
            new THREE.TorusGeometry(6, 1.5, 10, 16),
            new THREE.MeshStandardMaterial({ color: 0x00ffd5, roughness: 0.3, metalness: 0.5 })
          );
          torus.rotation.x = Math.PI / 2;
          return torus;
        }
        case 'PORT': {
          const dock = new THREE.Mesh(
            new THREE.BoxGeometry(16, 3, 10),
            new THREE.MeshStandardMaterial({ color: 0x3a6f9a })
          );
          dock.position.y = 1.5;
          return dock;
        }
        case 'WIND_TURBINE': {
          const turbine = createWindmill();
          turbine.scale.setScalar(0.25);
          return turbine;
        }
        case 'ECOLE': {
          const building = new THREE.Mesh(
            new THREE.BoxGeometry(14, 8, 10),
            new THREE.MeshStandardMaterial({ color: 0xc87878 })
          );
          building.position.y = 4;
          return building;
        }
        case 'SKYSCRAPER': {
          const tower = new THREE.Mesh(
            new THREE.CylinderGeometry(6, 8, 60, 10),
            new THREE.MeshStandardMaterial({ color: 0x444a58, roughness: 0.4, metalness: 0.3 })
          );
          tower.position.y = 30;
          return tower;
        }
        case 'TRAFFIC_LIGHT': {
          const group = new THREE.Group();
          const pole = new THREE.Mesh(
            new THREE.CylinderGeometry(0.6, 0.6, 10, 8),
            new THREE.MeshStandardMaterial({ color: 0x2c2c2c })
          );
          pole.position.y = 5;
          group.add(pole);
          const lightMat = new THREE.MeshStandardMaterial({
            color: 0xff3b3b,
            emissive: 0xff3b3b,
            emissiveIntensity: 0.8
          });
          const light = new THREE.Mesh(new THREE.SphereGeometry(1.4, 10, 10), lightMat);
          light.position.set(0, 9, 0);
          group.add(light);
          group.userData.trafficLight = true;
          group.userData.lightMesh = light;
          return group;
        }
        default: {
          const sphere = new THREE.Mesh(
            new THREE.SphereGeometry(5, 10, 10),
            new THREE.MeshStandardMaterial({ color: POI_COLORS[type] ?? 0x00ff88 })
          );
          sphere.position.y = 5;
          return sphere;
        }
      }
    }
    
    // Create building with properly attached windows
    function createBuildingWithWindows(points, color, height, buildingType) {
      const group = new THREE.Group();
      
      // Calculate bounds
      let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
      const worldPoints = points.map(([nx, nz]) => {
        const [wx, wz] = toWorld(nx, nz);
        minX = Math.min(minX, wx);
        maxX = Math.max(maxX, wx);
        minZ = Math.min(minZ, wz);
        maxZ = Math.max(maxZ, wz);
        return new THREE.Vector2(wx, -wz);
      });
      
      const width = maxX - minX;
      const depth = maxZ - minZ;
      const cx = (minX + maxX) / 2;
      const cz = (minZ + maxZ) / 2;
      
      // Main building
      const shape = new THREE.Shape(worldPoints);
      const extrudeSettings = { steps: 1, depth: height, bevelEnabled: false };
      const buildingGeo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
      buildingGeo.rotateX(-Math.PI / 2);
      
      const buildingMat = new THREE.MeshStandardMaterial({ 
        color, roughness: 0.6, metalness: 0.2 
      });
      const building = new THREE.Mesh(buildingGeo, buildingMat);
      building.castShadow = true;
      building.receiveShadow = true;
      group.add(building);
      
      // Add windows if building is big enough - aligned per polygon edge (INSTANCED)
      if (width > 10 && depth > 10 && height > 10 && buildingType !== 'parking') {
        const litMatrices = [];
        const darkMatrices = [];

        const wGeo = WINDOW_GEO;

        const floorHeight = 10;
        const floors = Math.floor(height / floorHeight);
        const windowSpacing = 12;

        // Signed area to determine winding; used to keep normals outward
        let signedArea = 0;
        for (let i = 0; i < worldPoints.length; i++) {
          const p1 = worldPoints[i];
          const p2 = worldPoints[(i + 1) % worldPoints.length];
          signedArea += p1.x * p2.y - p2.x * p1.y;
        }
        const outwardSign = signedArea >= 0 ? 1 : -1;

        for (let i = 0; i < worldPoints.length; i++) {
          const p1 = worldPoints[i];
          const p2 = worldPoints[(i + 1) % worldPoints.length];
          const dir = p2.clone().sub(p1);
          const edgeLen = dir.length();
          if (edgeLen < 8) continue;

          const normal2 = new THREE.Vector2(dir.y, -dir.x).normalize().multiplyScalar(outwardSign);
          const count = Math.max(1, Math.floor((edgeLen - 6) / windowSpacing));

          for (let floor = 0; floor < floors; floor += 2) {
            const y = 4 + floor * floorHeight;

            for (let j = 0; j < count; j++) {
              const t = (j + 1) / (count + 1);
              const pos2 = p1.clone().add(dir.clone().multiplyScalar(t));

              // Convert 2D shape space -> world
              const worldX = pos2.x;
              const worldZ = -pos2.y;
              const normalX = normal2.x;
              const normalZ = -normal2.y;

              // Slight offset to avoid z-fighting and keep outside
              const px = worldX + normalX * 0.2;
              const pz = worldZ + normalZ * 0.2;

              // Build per-instance transform (plane faces +Z by default, so lookAt works)
              _tmpObj.position.set(px, y, pz);
              _tmpObj.lookAt(px + normalX, y, pz + normalZ);
              _tmpObj.updateMatrix();

              const windowLit = rng() > 0.3;
              (windowLit ? litMatrices : darkMatrices).push(_tmpObj.matrix.clone());
            }
          }
        }

        // Create instanced meshes (2 draw calls for all windows of this building)
        // Always create one batch entry per building (for future per-building control)
        const batch = { lit: null, dark: null };
        if (litMatrices.length) {
          const lit = makeInstanced(wGeo, WINDOW_MATS.day, litMatrices);
          lit.userData.batchType = "buildingLit";
          group.add(lit);
          batch.lit = lit;
        }
        if (darkMatrices.length) {
          const dark = makeInstanced(wGeo, WINDOW_MATS.day, darkMatrices);
          dark.userData.batchType = "buildingDark";
          group.add(dark);
          batch.dark = dark;
        }
        if (batch.lit || batch.dark) {
          buildingWindowBatches.push(batch);
        }
      }
      
      // Add roof details for certain types
      if (buildingType === 'residential') {
        // Flat roof with edge
        const roofGeo = new THREE.BoxGeometry(width - 2, 1.5, depth - 2);
        const roofMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
        const roof = new THREE.Mesh(roofGeo, roofMat);
        roof.position.set(cx, height + 0.75, cz);
        roof.castShadow = true;
        group.add(roof);
      }
      
      return group;
    }
    
    // ============================================
    // ZONE DATA - Carefully traced from MAP.png
    // ============================================
    
    const zones = [];
    const buildings = [];
    const buildingGroups = []; // Store building groups with attached windows
    
    // Keep base outlines handy for placement tests
    const ISLAND_POLY = [
      [0.05, 0.42], [0.06, 0.35], [0.09, 0.29], [0.14, 0.25],
      [0.20, 0.26], [0.26, 0.30], [0.30, 0.36], [0.32, 0.40],
      [0.30, 0.44], [0.26, 0.48], [0.20, 0.52], [0.14, 0.53],
      [0.09, 0.51], [0.06, 0.47]
    ];
    const MAINLAND_POLY = [
      [0.36, 0], [1, 0], [1, 1], [0.32, 1],
      [0.30, 0.85], [0.32, 0.70], [0.36, 0.55],
      [0.38, 0.42], [0.40, 0.30], [0.38, 0.15]
    ];
    
    // --- SEA --- (Left ~35% of map, following coastline)
    const seaPoints = [
      [0, 0], [0.32, 0], [0.34, 0.08], [0.36, 0.20], 
      [0.35, 0.35], [0.32, 0.45], [0.30, 0.58], 
      [0.28, 0.72], [0.27, 0.88], [0.30, 1], [0, 1]
    ];
    
    // --- BEACH (narrow strip along coastline) ---
    const beachPoints = [
      [0.32, 0], [0.35, 0], [0.37, 0.08], [0.39, 0.20],
      [0.38, 0.35], [0.35, 0.45], [0.33, 0.58],
      [0.31, 0.72], [0.30, 0.88], [0.33, 1], [0.30, 1],
      [0.27, 0.88], [0.28, 0.72], [0.30, 0.58],
      [0.32, 0.45], [0.35, 0.35], [0.36, 0.20], [0.34, 0.08]
    ];
    
    // --- ISLAND (boat/leaf shape pointing east toward bridge) ---
    const islandOutline = [
      [0.05, 0.42], [0.06, 0.35], [0.09, 0.29], [0.14, 0.25],
      [0.20, 0.26], [0.26, 0.30], [0.30, 0.36], [0.32, 0.40],
      [0.30, 0.44], [0.26, 0.48], [0.20, 0.52], [0.14, 0.53],
      [0.09, 0.51], [0.06, 0.47]
    ];
    
    // Island zones - traced from MAP.png
    const islandZones = {
      // B (Orange/Yellow) - Top left office on island
      islandB1: {
        points: [[0.06, 0.36], [0.10, 0.30], [0.13, 0.32], [0.09, 0.40]],
        color: 0xe8a848, // Orange-yellow
        type: 'office',
        label: 'B',
        height: 25
      },
      
      // J (Green) - Large central park with pond  
      islandJ: {
        points: [[0.10, 0.30], [0.20, 0.27], [0.25, 0.32], [0.25, 0.44], [0.10, 0.44]],
        color: COLORS.garden,
        type: 'garden',
        label: 'J',
        height: 0 // flat park
      },
      
      // B (Yellow triangles) - Right side of island
      islandB2: {
        points: [[0.25, 0.30], [0.30, 0.38], [0.25, 0.38]],
        color: COLORS.office,
        type: 'office',
        label: 'B',
        height: 30
      },
      islandB3: {
        points: [[0.25, 0.40], [0.30, 0.42], [0.25, 0.46]],
        color: COLORS.office,
        type: 'office', 
        label: 'B',
        height: 28
      },
      
      // ZC (Blue/Purple) - Small commercial on left
      islandZC: {
        points: [[0.06, 0.42], [0.09, 0.42], [0.09, 0.47], [0.06, 0.48]],
        color: 0x7868a8, // Purple-blue
        type: 'commercial',
        label: 'ZC',
        height: 18
      },
      
      // Q (Red) - Bottom residential strip with 3 sections
      islandQ1: {
        points: [[0.07, 0.48], [0.13, 0.47], [0.13, 0.52], [0.07, 0.51]],
        color: COLORS.residential,
        type: 'residential',
        label: 'Q',
        hasSchool: true,
        height: 20
      },
      islandQ2: {
        points: [[0.13, 0.47], [0.19, 0.48], [0.19, 0.52], [0.13, 0.52]],
        color: COLORS.residential,
        type: 'residential',
        label: 'Q',
        height: 18
      },
      islandQ3: {
        points: [[0.19, 0.48], [0.25, 0.49], [0.24, 0.52], [0.19, 0.52]],
        color: COLORS.residential,
        type: 'residential',
        label: 'Q',
        height: 22
      }
    };
    
    // --- MAINLAND ZONES --- Carefully traced from MAP.png
    
    const mainlandZones = {
      // Top diagonal strip - Q, Q, B, B going down along coast
      coastQ1: {
        points: [[0.36, 0.02], [0.42, 0.02], [0.42, 0.06], [0.37, 0.06]],
        color: COLORS.residential,
        type: 'residential',
        label: 'Q',
        height: 18
      },
      coastQ2: {
        points: [[0.37, 0.07], [0.42, 0.07], [0.42, 0.12], [0.38, 0.12]],
        color: COLORS.residential,
        type: 'residential',
        label: 'Q',
        height: 20
      },
      coastB1: {
        points: [[0.38, 0.13], [0.43, 0.13], [0.43, 0.18], [0.39, 0.18]],
        color: COLORS.office,
        type: 'office',
        label: 'B',
        height: 32
      },
      coastB2: {
        points: [[0.39, 0.19], [0.43, 0.19], [0.43, 0.26], [0.40, 0.26]],
        color: COLORS.office,
        type: 'office',
        label: 'B',
        height: 35
      },
      
      // Large R (Red/Pink restaurant) block - prominent "R" on map
      bigR: {
        points: [[0.44, 0.02], [0.55, 0.02], [0.55, 0.20], [0.44, 0.20]],
        color: 0xc87868, // Red-pink
        type: 'restaurant',
        label: 'R',
        height: 28
      },
      
      // Q (Red) below big R
      underRQ: {
        points: [[0.44, 0.21], [0.55, 0.21], [0.55, 0.30], [0.44, 0.30]],
        color: COLORS.residential,
        type: 'residential',
        label: 'Q',
        height: 22
      },
      
      // Column going down from coastal area
      colJ1: {
        points: [[0.44, 0.31], [0.50, 0.31], [0.50, 0.38], [0.44, 0.38]],
        color: COLORS.garden,
        type: 'garden',
        label: 'J',
        height: 0
      },
      colZC1: {
        points: [[0.44, 0.39], [0.50, 0.39], [0.50, 0.48], [0.44, 0.48]],
        color: COLORS.commercial,
        type: 'commercial',
        label: 'ZC',
        height: 22
      },
      colB1: {
        points: [[0.44, 0.49], [0.50, 0.49], [0.50, 0.56], [0.44, 0.56]],
        color: 0xc89848, // Brown-yellow
        type: 'office',
        label: 'B',
        height: 28
      },
      colQ_school: {
        points: [[0.44, 0.57], [0.50, 0.57], [0.50, 0.66], [0.44, 0.66]],
        color: COLORS.residential,
        type: 'residential',
        label: 'Q',
        hasSchool: true,
        height: 20
      },
      colCi: {
        points: [[0.44, 0.67], [0.50, 0.67], [0.50, 0.74], [0.44, 0.74]],
        color: COLORS.cinema,
        type: 'cinema',
        label: 'Ci',
        height: 24
      },
      colFf: {
        points: [[0.44, 0.75], [0.50, 0.75], [0.50, 0.85], [0.44, 0.85]],
        color: COLORS.fairground,
        type: 'fairground',
        label: 'ff',
        height: 8
      },
      
      // Port at bottom (water area)
      port: {
        points: [[0.32, 0.86], [0.50, 0.86], [0.50, 0.98], [0.32, 0.98]],
        color: COLORS.port,
        type: 'port',
        label: 'P',
        height: 0
      },
      
      // Hospital "H" - Large grey building
      hospital: {
        points: [[0.51, 0.10], [0.64, 0.10], [0.64, 0.35], [0.51, 0.35]],
        color: COLORS.hospital,
        type: 'hospital',
        label: 'H',
        height: 38
      },
      
      // Pink R (restaurant) below hospital
      hospR: {
        points: [[0.51, 0.36], [0.56, 0.36], [0.56, 0.43], [0.51, 0.43]],
        color: 0xd8a8a8, // Pink
        type: 'restaurant',
        label: 'R',
        height: 18
      },
      
      // B (Yellow) office below R
      hospB: {
        points: [[0.51, 0.44], [0.56, 0.44], [0.56, 0.52], [0.51, 0.52]],
        color: COLORS.office,
        type: 'office',
        label: 'B',
        height: 30
      },
      
      // ZC (Blue) commercial zones
      hospZC1: {
        points: [[0.51, 0.53], [0.58, 0.53], [0.58, 0.62], [0.51, 0.62]],
        color: COLORS.commercial,
        type: 'commercial',
        label: 'ZC',
        height: 22
      },
      
      // ZC Triangle (Blue)
      hospZC_tri: {
        points: [[0.51, 0.63], [0.62, 0.63], [0.51, 0.75]],
        color: COLORS.commercial,
        type: 'commercial',
        label: 'ZC',
        height: 20
      },
      
      // J garden area next to hospital
      midJ: {
        points: [[0.57, 0.36], [0.64, 0.36], [0.64, 0.44], [0.57, 0.44]],
        color: COLORS.garden,
        type: 'garden',
        label: 'J',
        height: 0
      },
      
      // J - Big blue commercial zone (marked J but blue on map)
      bigBlueJ: {
        points: [[0.57, 0.45], [0.66, 0.45], [0.66, 0.62], [0.57, 0.62]],
        color: COLORS.commercial,
        type: 'commercial',
        label: 'J',
        height: 25
      },
      
      // Long vertical GREEN park strip
      longPark: {
        points: [[0.66, 0.02], [0.71, 0.02], [0.71, 0.70], [0.66, 0.70]],
        color: COLORS.garden,
        type: 'garden',
        label: 'J',
        height: 0
      },
      
      // East of long park - Top row
      eastPK1: {
        points: [[0.72, 0.02], [0.80, 0.02], [0.80, 0.07], [0.72, 0.07]],
        color: COLORS.parking,
        type: 'parking',
        label: 'PK',
        height: 3
      },
      eastMA: {
        points: [[0.72, 0.08], [0.82, 0.08], [0.82, 0.16], [0.72, 0.16]],
        color: COLORS.mairie,
        type: 'mairie',
        label: 'MA',
        height: 32
      },
      
      // M zone (deep blue)
      eastM: {
        points: [[0.82, 0.08], [0.90, 0.08], [0.90, 0.16], [0.82, 0.16]],
        color: 0x4868a8, // Deep blue
        type: 'other',
        label: 'M',
        height: 8
      },
      
      // H‚òÖ Hotels (Dark green triangular)
      eastH1: {
        points: [[0.72, 0.17], [0.78, 0.17], [0.72, 0.28]],
        color: COLORS.hotel,
        type: 'hotel',
        label: 'H‚òÖ',
        height: 45
      },
      eastH2: {
        points: [[0.78, 0.17], [0.83, 0.17], [0.78, 0.28]],
        color: COLORS.hotel,
        type: 'hotel',
        label: 'H‚òÖ',
        height: 48
      },
      
      // J garden next to hotels
      eastJ1: {
        points: [[0.72, 0.29], [0.78, 0.29], [0.78, 0.36], [0.72, 0.36]],
        color: COLORS.garden,
        type: 'garden',
        label: 'J',
        height: 0
      },
      // O zone (brown)
      eastO: {
        points: [[0.72, 0.37], [0.78, 0.37], [0.78, 0.44], [0.72, 0.44]],
        color: 0x987858, // Brown
        type: 'other',
        label: 'O',
        height: 20
      },
      
      // ZC Triangle (Blue) pointing down
      eastZC_tri: {
        points: [[0.72, 0.45], [0.78, 0.45], [0.72, 0.58]],
        color: COLORS.commercial,
        type: 'commercial',
        label: 'ZC',
        height: 22
      },
      
      // J garden 
      eastJ2: {
        points: [[0.72, 0.59], [0.78, 0.59], [0.78, 0.70], [0.72, 0.70]],
        color: COLORS.garden,
        type: 'garden',
        label: 'J',
        height: 0
      },
      
      // R (Red restaurant) east
      eastR: {
        points: [[0.78, 0.45], [0.84, 0.45], [0.84, 0.56], [0.78, 0.56]],
        color: COLORS.restaurant,
        type: 'restaurant',
        label: 'R',
        height: 18
      },
      
      // B Skyscraper zone (tall building)
      skyscraper: {
        points: [[0.83, 0.29], [0.90, 0.29], [0.90, 0.44], [0.83, 0.44]],
        color: 0xc8c858, // Light yellow
        type: 'skyscraper',
        label: 'B',
        height: 180 // Very tall!
      },
      
      // ZC below skyscraper
      eastZC2: {
        points: [[0.83, 0.45], [0.90, 0.45], [0.90, 0.56], [0.83, 0.56]],
        color: COLORS.commercial,
        type: 'commercial',
        label: 'ZC',
        height: 20
      },
      
      // J garden east
      eastJ3: {
        points: [[0.83, 0.57], [0.90, 0.57], [0.90, 0.70], [0.83, 0.70]],
        color: COLORS.garden,
        type: 'garden',
        label: 'J',
        height: 0
      },
      
      // Stadium area (White "S")
      stadium: {
        points: [[0.66, 0.71], [0.90, 0.71], [0.90, 0.92], [0.66, 0.92]],
        color: COLORS.stadium,
        type: 'stadium',
        label: 'S',
        height: 0 // Flat - stadium details added separately
      },
      
      // Transport stations T with zigzag roofs (bottom right)
      transport1: {
        points: [[0.58, 0.76], [0.66, 0.76], [0.66, 0.86], [0.58, 0.86]],
        color: COLORS.transport,
        type: 'transport',
        label: 'T',
        height: 18
      },
      transport2: {
        points: [[0.91, 0.56], [0.98, 0.56], [0.98, 0.70], [0.91, 0.70]],
        color: COLORS.transport,
        type: 'transport',
        label: 'T',
        height: 18
      },
      
      // PK Parking at bottom
      bottomPK: {
        points: [[0.66, 0.93], [0.80, 0.93], [0.80, 0.98], [0.66, 0.98]],
        color: COLORS.parking,
        type: 'parking',
        label: 'PK',
        height: 3
      },
      
      // Far east - Z green zones
      farEastZ1: {
        points: [[0.91, 0.02], [0.98, 0.02], [0.98, 0.18], [0.91, 0.18]],
        color: COLORS.garden,
        type: 'garden',
        label: 'Z',
        height: 0
      },
      farEastZ2: {
        points: [[0.91, 0.19], [0.98, 0.19], [0.98, 0.34], [0.91, 0.34]],
        color: COLORS.garden,
        type: 'garden',
        label: 'Z',
        height: 0
      },
      
      // D Rubbish tip (grey)
      rubbish: {
        points: [[0.91, 0.35], [0.98, 0.35], [0.98, 0.55], [0.91, 0.55]],
        color: COLORS.utilities,
        type: 'rubbish',
        label: 'D',
        height: 8
      },
      electric: {
        points: [[0.91, 0.51], [0.98, 0.51], [0.98, 0.70], [0.91, 0.70]],
        color: COLORS.utilities,
        type: 'electric',
        label: '‚ö°'
      },
      waterTreatment: {
        points: [[0.91, 0.71], [0.98, 0.71], [0.98, 0.98], [0.91, 0.98]],
        color: COLORS.utilities,
        type: 'water',
        label: 'üíß'
      }
    };
    
    // ============================================
    // BUILD CITY - PHASE 1: 2D ZONES
    // ============================================
    
    function buildPhase1() {
      const terrainDefs = buildLegacyTerrainDefs({
        seaPoints,
        beachPoints,
        islandOutline,
        colors: COLORS
      });
      createLegacyTerrain({ layer: LAYERS.terrain, createPolygon, defs: terrainDefs });
      
      createZoneMeshes({
        layer: LAYERS.zones,
        zoneDefs: islandZones,
        zones,
        registry: ZONE_REGISTRY,
        createPolygon,
        y: Y.zones
      });
      
      createZoneMeshes({
        layer: LAYERS.zones,
        zoneDefs: mainlandZones,
        zones,
        registry: ZONE_REGISTRY,
        createPolygon,
        y: Y.zones
      });
      
      // Bridge
      createBridge();
    }
    
    // ============================================
    // BUILD CITY - PHASE 2: 3D BUILDINGS
    // ============================================
    
    function buildPhase2() {
      // Building heights by type
      const heights = {
        residential: 25,
        office: 40,
        commercial: 20,
        garden: 0, // No buildings
        hospital: 35,
        restaurant: 15,
        police: 20,
        parking: 5,
        mairie: 30,
        hotel: 50,
        stadium: 15,
        transport: 20,
        cinema: 25,
        fairground: 10,
        port: 0,
        rubbish: 8,
        electric: 0,
        water: 0,
        skyscraper: 120,
        other: 20
      };
      
      const zoneByName = Object.fromEntries(zones.map(z => [z.name, z]));
      
      zones.forEach(zoneMesh => {
        const data = zoneMesh.userData;
        // Skip zones that don't need buildings or have custom implementations
        if (!data.type || data.type === 'garden' || data.type === 'port' || data.type === 'stadium' || data.type === 'skyscraper') return;
        
        // Use height from zone data if available, otherwise use type default
        let height = data.height !== undefined ? data.height : (heights[data.type] || 20);
        
        // Skip if height is 0 or very small
        if (height < 5) return;
        
        // Create building group with attached windows
        const buildingGroup = createBuildingWithWindows(data.points, data.color, height, data.type);
        buildingGroup.name = zoneMesh.name + '_building';
        buildingGroup.userData = data;
        buildingGroup.position.y = Y.buildings;
        LAYERS.buildings.add(buildingGroup);
        buildings.push(buildingGroup);
        buildingGroups.push(buildingGroup);
        
        // Update registry
        const entry = ZONE_REGISTRY[zoneMesh.name];
        if (entry) entry.buildingGroup = buildingGroup;
      });
      
      // Special buildings driven by zone centroids when available
      if (zoneByName.hospital) {
        const [hx, hz] = worldCentroid(zoneByName.hospital.userData.points);
        createHospitalCrossAt(hx, hz);
      }
      if (zoneByName.stadium) {
        const [sx, sz] = worldCentroid(zoneByName.stadium.userData.points);
        createStadiumDetailsAt(sx, sz);
      }
      createWindmills();
      createMetroStations();
      createParkTrees();
      if (zoneByName.islandJ) {
        const [px, pz] = worldCentroid(zoneByName.islandJ.userData.points);
        createPondAt(px, pz);
      }
      createRoads();
      createStreetLamps();
      createElectricPylons();
      createWaterTreatment();
      
      // Ferris wheel in fairground (colFf zone is at 0.44-0.50, 0.75-0.85)
      if (zoneByName.colFf) {
        const [ffX, ffZ] = worldCentroid(zoneByName.colFf.userData.points);
        const ferrisWheel = createFerrisWheel(ffX, ffZ);
        ferrisWheel.name = 'ferrisWheel';
        LAYERS.props.add(ferrisWheel);
        ferrisWheelRef = ferrisWheel;  // Cache reference
      }
      
      // Train stations with zigzag roofs
      if (zoneByName.transport1) {
        const trainStation1 = createTrainStation(zoneByName.transport1.userData.points, 'T1');
        LAYERS.buildings.add(trainStation1);
      }
      if (zoneByName.transport2) {
        const trainStation2 = createTrainStation(zoneByName.transport2.userData.points, 'T2');
        LAYERS.buildings.add(trainStation2);
      }
      
      // Port boats
      if (zoneByName.port) {
        const [portX, portZ] = worldCentroid(zoneByName.port.userData.points);
        createPortBoatsAt(portX, portZ);
      }
      
      // Hotel stars
      const hotelZones = ['eastH1', 'eastH2'].filter(n => zoneByName[n]);
      if (hotelZones.length) {
        const hotelPositions = hotelZones.map(n => worldCentroid(zoneByName[n].userData.points));
        createHotelStarsAt(hotelPositions);
      }
      
      // Schools in residential areas
      const schoolZones = zones.filter(z => z.userData.hasSchool);
      schoolZones.forEach(zone => {
        const pts = zone.userData.points;
        if (pts && pts.length >= 3) {
          let cx = 0, cz = 0;
          pts.forEach(([x, z]) => { cx += x; cz += z; });
          cx /= pts.length;
          cz /= pts.length;
          const [wx, wz] = toWorld(cx, cz);
          const school = createSchool(wx, wz);
          LAYERS.buildings.add(school);
        }
      });
      
      // Town Hall (Mairie) with columns
      if (zoneByName.eastMA) {
        const [maX, maZ] = worldCentroid(zoneByName.eastMA.userData.points);
        const townHall = createTownHall(maX, maZ);
        LAYERS.buildings.add(townHall);
      }
      
      // Cinema with marquee
      if (zoneByName.colCi) {
        const [ciX, ciZ] = worldCentroid(zoneByName.colCi.userData.points);
        const cinema = createCinema(ciX, ciZ);
        LAYERS.buildings.add(cinema);
      }
      
      // Skyscraper with glass facade
      if (zoneByName.skyscraper) {
        const [skX, skZ] = worldCentroid(zoneByName.skyscraper.userData.points);
        const skyscraper = createSkyscraper(skX, skZ);
        LAYERS.buildings.add(skyscraper);
      }
    }
    
    // ============================================
    // SPECIAL FEATURES
    // ============================================
    
    function createBridge() {
      const bridgeGroup = new THREE.Group();
      bridgeGroup.name = 'bridge';
      
      // Bridge spans from island eastern tip to mainland coast
      // Anchored firmly on both sides to prevent gaps
      const [x1, z1] = toWorld(0.30, 0.40);  // Island end (deeper anchor)
      const [x2, z2] = toWorld(0.40, 0.40);  // Mainland end (deeper anchor)
      const bridgeLength = Math.abs(x2 - x1); 
      const bridgeCenterX = (x1 + x2) / 2;
      const bridgeCenterZ = (z1 + z2) / 2;
      
      // Bridge deck
      const deckGeo = new THREE.BoxGeometry(bridgeLength, 4, 20);
      const deckMat = new THREE.MeshStandardMaterial({ color: 0x505050, roughness: 0.9 });
      const deck = new THREE.Mesh(deckGeo, deckMat);
      deck.position.set(bridgeCenterX, 5, bridgeCenterZ);
      deck.castShadow = true;
      deck.receiveShadow = true;
      bridgeGroup.add(deck);
      
      // Support pillars - 4 pillars for stability
      const pillarGeo = new THREE.CylinderGeometry(2.5, 3.5, 20, 12);
      const pillarMat = new THREE.MeshStandardMaterial({ color: 0x606060 });
      
      for (let i = 0; i < 4; i++) {
        const pillar = new THREE.Mesh(pillarGeo, pillarMat);
        const t = (i + 0.5) / 4;
        pillar.position.set(
          x1 + (x2 - x1) * t,
          -5,
          bridgeCenterZ
        );
        pillar.castShadow = true;
        bridgeGroup.add(pillar);
      }
      
      // Railings
      const railGeo = new THREE.BoxGeometry(bridgeLength, 3, 0.8);
      const railMat = new THREE.MeshStandardMaterial({ color: 0x404040 });
      const rail1 = new THREE.Mesh(railGeo, railMat);
      const rail2 = new THREE.Mesh(railGeo, railMat);
      rail1.position.set(bridgeCenterX, 8, bridgeCenterZ - 8);
      rail2.position.set(bridgeCenterX, 8, bridgeCenterZ + 8);
      bridgeGroup.add(rail1, rail2);
      
      LAYERS.props.add(bridgeGroup);
    }
    
    function createHospitalCrossAt(cx, cz) {
      const crossMat = new THREE.MeshStandardMaterial({ 
        color: 0xff0000, 
        emissive: 0x330000,
        roughness: 0.3
      });
      
      const arm1 = new THREE.Mesh(
        new THREE.BoxGeometry(8, 4, 24),
        crossMat
      );
      const arm2 = new THREE.Mesh(
        new THREE.BoxGeometry(24, 4, 8),
        crossMat
      );
      
      const crossGroup = new THREE.Group();
      crossGroup.add(arm1, arm2);
      crossGroup.position.set(cx, 42, cz);
      LAYERS.props.add(crossGroup);
    }
    
    function createStadiumDetailsAt(cx, cz) {
      // Grass field (oval)
      const fieldShape = new THREE.Shape();
      fieldShape.ellipse(0, 0, 60, 40, 0, Math.PI * 2);
      const fieldGeo = new THREE.ShapeGeometry(fieldShape);
      fieldGeo.rotateX(-Math.PI / 2);
      const fieldMat = new THREE.MeshStandardMaterial({ color: 0x2d8a2d });
      const field = new THREE.Mesh(fieldGeo, fieldMat);
      field.position.set(cx, 2, cz);
      field.receiveShadow = true;
      LAYERS.props.add(field);
      
      // Track (ring around field)
      const trackShape = new THREE.Shape();
      trackShape.ellipse(0, 0, 70, 50, 0, Math.PI * 2);
      const trackHole = new THREE.Path();
      trackHole.ellipse(0, 0, 60, 40, 0, Math.PI * 2);
      trackShape.holes.push(trackHole);
      const trackGeo = new THREE.ShapeGeometry(trackShape);
      trackGeo.rotateX(-Math.PI / 2);
      const trackMat = new THREE.MeshStandardMaterial({ color: 0xc87848 });
      const track = new THREE.Mesh(trackGeo, trackMat);
      track.position.set(cx, 2.1, cz);
      LAYERS.props.add(track);
      
      // Seating sections (colored stands)
      const seatColors = [0x3366cc, 0xcc3333, 0x33cc33, 0xcccc33];
      const seatCount = 8;
      
      for (let i = 0; i < seatCount; i++) {
        const angle = (i / seatCount) * Math.PI * 2;
        const nextAngle = ((i + 1) / seatCount) * Math.PI * 2;
        
        const innerR = 72;
        const outerR = 90;
        
        const seatShape = new THREE.Shape();
        seatShape.moveTo(Math.cos(angle) * innerR, Math.sin(angle) * innerR * 0.7);
        seatShape.lineTo(Math.cos(angle) * outerR, Math.sin(angle) * outerR * 0.7);
        seatShape.lineTo(Math.cos(nextAngle) * outerR, Math.sin(nextAngle) * outerR * 0.7);
        seatShape.lineTo(Math.cos(nextAngle) * innerR, Math.sin(nextAngle) * innerR * 0.7);
        seatShape.closePath();
        
        const seatGeo = new THREE.ExtrudeGeometry(seatShape, { depth: 15, bevelEnabled: false });
        seatGeo.rotateX(-Math.PI / 2);
        const seatMat = new THREE.MeshStandardMaterial({ color: seatColors[i % 4] });
        const seat = new THREE.Mesh(seatGeo, seatMat);
        seat.position.set(cx, 2, cz);
        seat.castShadow = false;  // Decorative - no shadow
        LAYERS.props.add(seat);
      }
    }
    
    function createWindmills() {
      // Windmills moved EXTREMELY far away to be absolutely safe
      // Far west (negative X) and far north/south
      const windmillPositions = [
        // Extreme West (off map to left)
        [-0.10, 0.10], [-0.10, 0.20], [-0.10, 0.60], [-0.10, 0.70], [-0.10, 0.80],
        // Far North (top edge)
        [0.00, 0.02], [0.05, 0.02], [0.10, 0.02], 
        // Far South (bottom edge)
        [0.00, 0.95], [0.05, 0.95], [0.10, 0.95]
      ];
      
      const windmillGroup = new THREE.Group();
      windmillGroup.name = 'windmills';
      windmillsGroup = windmillGroup;  // Cache reference
      
      windmillPositions.forEach((pos) => {
        const nx = pos[0], nz = pos[1];
        const [x, z] = toWorld(nx, nz);
        const windmill = createWindmill();
        windmill.position.set(x, -2, z);
        windmill.userData.rotationSpeed = 0.01 + rng() * 0.005;
        windmill.userData.rotationOffset = rng() * Math.PI * 2;
        windmillGroup.add(windmill);
      });
      
      LAYERS.props.add(windmillGroup);
    }
    
    function createWindmill() {
      const group = new THREE.Group();
      
      // Tower
      const towerGeo = new THREE.CylinderGeometry(2, 4, 60, 8);
      const towerMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
      const tower = new THREE.Mesh(towerGeo, towerMat);
      tower.position.y = 30;
      tower.castShadow = false;  // Decorative - no shadow
      group.add(tower);
      
      // Nacelle
      const nacelleGeo = new THREE.BoxGeometry(8, 6, 6);
      const nacelle = new THREE.Mesh(nacelleGeo, towerMat);
      nacelle.position.set(0, 60, 0);
      group.add(nacelle);
      
      // Blades
      const bladesGroup = new THREE.Group();
      bladesGroup.position.set(0, 60, 4);
      
      const bladeGeo = new THREE.BoxGeometry(2, 28, 1);
      const bladeMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
      
      for (let i = 0; i < 3; i++) {
        const blade = new THREE.Mesh(bladeGeo, bladeMat);
        blade.position.y = 14;
        const bladeContainer = new THREE.Group();
        bladeContainer.add(blade);
        bladeContainer.rotation.z = (i * Math.PI * 2) / 3;
        bladesGroup.add(bladeContainer);
      }
      
      group.add(bladesGroup);
      group.userData.blades = bladesGroup;
      
      return group;
    }
    
    function createMetroStations() {
      const metroPositions = [
        [0.12, 0.35], [0.22, 0.52],  // Island
        [0.42, 0.25], [0.42, 0.55],  // Coastal
        [0.55, 0.40], [0.72, 0.20],  // Mid city
        [0.88, 0.17]                  // East
      ];
      
      metroPositions.forEach(pos => {
        const [x, z] = toWorld(pos[0], pos[1]);
        const metro = createMetroEntrance();
        metro.position.set(x, 1, z);
        LAYERS.props.add(metro);
      });
    }
    
    function createMetroEntrance() {
      const group = new THREE.Group();
      
      // Entrance structure
      const entranceGeo = new THREE.BoxGeometry(10, 8, 10);
      const entranceMat = new THREE.MeshStandardMaterial({ color: 0x505050 });
      const entrance = new THREE.Mesh(entranceGeo, entranceMat);
      entrance.position.y = 4;
      entrance.castShadow = false;  // Small decorative - no shadow
      group.add(entrance);
      
      // Metro sign (floating M)
      const signGroup = new THREE.Group();
      
      // Circle background
      const circleGeo = new THREE.CircleGeometry(4, 32);
      const circleMat = new THREE.MeshStandardMaterial({ 
        color: 0x0055aa, 
        emissive: 0x002255,
        side: THREE.DoubleSide 
      });
      const circle = new THREE.Mesh(circleGeo, circleMat);
      signGroup.add(circle);
      
      // M letter (simple box representation)
      const mGeo = new THREE.BoxGeometry(5, 4, 0.5);
      const mMat = new THREE.MeshStandardMaterial({ 
        color: 0xffffff,
        emissive: 0x333333
      });
      const m = new THREE.Mesh(mGeo, mMat);
      m.position.z = 0.3;
      signGroup.add(m);
      
      signGroup.position.set(0, 15, 0);
      signGroup.rotation.y = Math.PI / 4;
      group.add(signGroup);
      
      return group;
    }
    
    function createParkTrees() {
      // Find all garden zones
      const gardenZones = zones.filter(z => z.userData.type === 'garden');
      
      gardenZones.forEach(zone => {
        const pts = zone.userData.points;
        if (!pts || pts.length < 3) return;
        
        // Calculate bounds
        let minX = 1, maxX = 0, minZ = 1, maxZ = 0;
        pts.forEach(([x, z]) => {
          minX = Math.min(minX, x);
          maxX = Math.max(maxX, x);
          minZ = Math.min(minZ, z);
          maxZ = Math.max(maxZ, z);
        });
        
        // Skip garden zones that are too small
        if ((maxX - minX) < 0.02 || (maxZ - minZ) < 0.02) return;
        
        // Place trees - check they're BOTH within the zone polygon AND on land
        const area = (maxX - minX) * (maxZ - minZ);
        const treeCount = Math.min(30, Math.floor(area * 300)); // Reduce tree count
        
        for (let i = 0; i < treeCount; i++) {
          const nx = minX + rng() * (maxX - minX);
          const nz = minZ + rng() * (maxZ - minZ);
          
          // Must be inside the actual zone polygon
          if (!pointInPolygon(nx, nz, pts)) continue;
          
          // Must also be on island or mainland land mass
          const isOnIsland = pointInPolygon(nx, nz, ISLAND_POLY);
          const isOnMainland = pointInPolygon(nx, nz, MAINLAND_POLY);
          if (!isOnIsland && !isOnMainland) continue;
          
          const [x, z] = toWorld(nx, nz);
          
          const tree = createTree();
          tree.position.set(x, 1, z);
          tree.scale.setScalar(0.4 + rng() * 0.4);
          LAYERS.props.add(tree);
        }
      });
    }
    
    function createTree() {
      const group = new THREE.Group();
      
      // Trunk
      const trunkGeo = new THREE.CylinderGeometry(1, 1.5, 8, 6);
      const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
      const trunk = new THREE.Mesh(trunkGeo, trunkMat);
      trunk.position.y = 4;
      trunk.castShadow = false;  // Decorative - no shadow
      group.add(trunk);
      
      // Foliage
      const foliageGeo = new THREE.SphereGeometry(6, 8, 6);
      const foliageMat = new THREE.MeshStandardMaterial({ 
        color: 0x2d5a2d,
        roughness: 0.9
      });
      const foliage = new THREE.Mesh(foliageGeo, foliageMat);
      foliage.position.y = 12;
      foliage.scale.y = 1.2;
      foliage.castShadow = false;  // Decorative - no shadow
      group.add(foliage);
      
      return group;
    }
    
    // Create Ferris wheel for fairground
    function createFerrisWheel(x, z) {
      const group = new THREE.Group();
      
      // Support structure
      const supportGeo = new THREE.BoxGeometry(3, 50, 3);
      const supportMat = new THREE.MeshStandardMaterial({ color: 0x606060 });
      const support1 = new THREE.Mesh(supportGeo, supportMat);
      const support2 = new THREE.Mesh(supportGeo, supportMat);
      support1.position.set(-12, 25, 0);
      support2.position.set(12, 25, 0);
      support1.rotation.z = 0.15;
      support2.rotation.z = -0.15;
      group.add(support1, support2);
      
      // Wheel rim
      const wheelGroup = new THREE.Group();
      const rimGeo = new THREE.TorusGeometry(20, 1, 8, 32);
      const rimMat = new THREE.MeshStandardMaterial({ color: 0xff4444 });
      const rim = new THREE.Mesh(rimGeo, rimMat);
      wheelGroup.add(rim);
      
      // Spokes and cabins
      const cabinColors = [0xff4444, 0x44ff44, 0x4444ff, 0xffff44, 0xff44ff, 0x44ffff];
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        
        // Spoke
        const spokeGeo = new THREE.BoxGeometry(0.5, 40, 0.5);
        const spoke = new THREE.Mesh(spokeGeo, supportMat);
        spoke.rotation.z = angle;
        wheelGroup.add(spoke);
        
        // Cabin
        const cabinGeo = new THREE.BoxGeometry(6, 8, 6);
        const cabinMat = new THREE.MeshStandardMaterial({ 
          color: cabinColors[i % cabinColors.length] 
        });
        const cabin = new THREE.Mesh(cabinGeo, cabinMat);
        cabin.position.set(Math.cos(angle) * 20, Math.sin(angle) * 20, 0);
        cabin.userData.baseAngle = angle;
        wheelGroup.add(cabin);
      }
      
      wheelGroup.position.y = 35;
      wheelGroup.rotation.x = Math.PI / 2;
      group.add(wheelGroup);
      group.userData.wheel = wheelGroup;
      
      group.position.set(x, 1, z);
      return group;
    }
    
    // Create zigzag roof for train stations
    function createTrainStation(points, label) {
      const group = new THREE.Group();
      
      // Get bounds
      let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
      points.forEach(([nx, nz]) => {
        const [x, z] = toWorld(nx, nz);
        minX = Math.min(minX, x);
        maxX = Math.max(maxX, x);
        minZ = Math.min(minZ, z);
        maxZ = Math.max(maxZ, z);
      });
      
      const cx = (minX + maxX) / 2;
      const cz = (minZ + maxZ) / 2;
      const width = maxX - minX;
      const depth = maxZ - minZ;
      
      // Base building
      const baseGeo = new THREE.BoxGeometry(width, 15, depth);
      const baseMat = new THREE.MeshStandardMaterial({ color: COLORS.transport });
      const base = new THREE.Mesh(baseGeo, baseMat);
      base.position.set(cx, 8.5, cz);
      base.castShadow = true;
      group.add(base);
      
      // Zigzag roof
      const roofHeight = 8;
      const segments = 4;
      const segmentWidth = width / segments;
      
      for (let i = 0; i < segments; i++) {
        const roofGeo = new THREE.ConeGeometry(segmentWidth / 1.5, roofHeight, 4);
        const roofMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
        const roof = new THREE.Mesh(roofGeo, roofMat);
        roof.position.set(
          minX + segmentWidth / 2 + i * segmentWidth,
          16 + roofHeight / 2,
          cz
        );
        roof.rotation.y = Math.PI / 4;
        roof.castShadow = false;  // Decorative - no shadow
        group.add(roof);
      }
      
      // Platform markings (train tracks)
      const trackGeo = new THREE.BoxGeometry(width * 0.9, 0.2, 2);
      const trackMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
      for (let i = 0; i < 3; i++) {
        const track = new THREE.Mesh(trackGeo, trackMat);
        track.position.set(cx, 1.1, cz - depth/3 + i * depth/3);
        group.add(track);
      }
      
      return group;
    }
    
    // Create roads between zones
    function createRoads() {
      const roadMat = new THREE.MeshStandardMaterial({ 
        color: 0x404040,
        roughness: 0.9
      });
      
      const sidewalkMat = new THREE.MeshStandardMaterial({ 
        color: 0x707070,
        roughness: 0.8
      });
      
      // Roads placed in gaps between zone boundaries (streets on map)
      // Horizontal roads at zone boundaries
      const hRoadPositions = [0.06, 0.12, 0.22, 0.32, 0.44, 0.56, 0.70, 0.76, 0.92];
      // Vertical roads at zone boundaries  
      const vRoadPositions = [0.44, 0.50, 0.56, 0.62, 0.66, 0.72, 0.78, 0.82, 0.90];
      
      // Shared dash geometry and material (reused for all roads)
      const dashGeo = new THREE.BoxGeometry(15, 0.1, 0.5);
      const dashMat = new THREE.MeshStandardMaterial({ color: 0xdddd44 });
      
      // Create road segments that fill spaces between buildings
      hRoadPositions.forEach(nz => {
        const [, z] = toWorld(0.5, nz);
        // Create road from coast to east edge
        const [x1] = toWorld(0.40, 0);
        const [x2] = toWorld(0.98, 0);
        
        // Road surface
        const roadGeo = new THREE.BoxGeometry(x2 - x1, 0.3, 12);
        const road = new THREE.Mesh(roadGeo, roadMat);
        road.position.set((x1 + x2) / 2, Y.roads, z);
        road.receiveShadow = true;
        road.material.polygonOffset = true;
        road.material.polygonOffsetFactor = -1;
        road.material.polygonOffsetUnits = -1;
        LAYERS.roads.add(road);
        
        // ‚úÖ Instanced dashes: 1 draw call instead of 20+
        const dashCount = 20;
        const dashes = new THREE.InstancedMesh(dashGeo, dashMat, dashCount);
        for (let i = 0; i < dashCount; i++) {
          _tmpObj.position.set(x1 + 30 + i * 30, 1.05, z);
          _tmpObj.rotation.set(0, 0, 0);
          _tmpObj.updateMatrix();
          dashes.setMatrixAt(i, _tmpObj.matrix);
        }
        dashes.instanceMatrix.needsUpdate = true;
        dashes.castShadow = false;
        dashes.receiveShadow = false;
        LAYERS.roads.add(dashes);
      });
      
      vRoadPositions.forEach(nx => {
        const [x] = toWorld(nx, 0);
        const [, z1] = toWorld(0, 0.02);
        const [, z2] = toWorld(0, 0.96);
        
        // Road surface
        const roadGeo = new THREE.BoxGeometry(12, 0.3, Math.abs(z2 - z1));
        const road = new THREE.Mesh(roadGeo, roadMat);
        road.position.set(x, Y.roads, (z1 + z2) / 2);
        road.receiveShadow = true;
        road.material.polygonOffset = true;
        road.material.polygonOffsetFactor = -1;
        road.material.polygonOffsetUnits = -1;
        LAYERS.roads.add(road);
      });
      
      // Add some cars
      createCars();
    }
    
    // Cars with headlights that drive on roads
    const cars = [];
    const warningLights = [];
    const marqueeLights = [];
    const CAR_ASSETS = {
      bodyGeo: null,
      roofGeo: null,
      wheelGeo: null,
      headlightGeo: null,
      wheelMat: null,
      headlightMat: null,
      tailMat: null,
      bodyMats: new Map()
    };

    function getSharedCarAssets() {
      if (!CAR_ASSETS.bodyGeo) {
        CAR_ASSETS.bodyGeo = new THREE.BoxGeometry(8, 3, 4);
        CAR_ASSETS.bodyGeo.userData.shared = true;
        CAR_ASSETS.roofGeo = new THREE.BoxGeometry(4, 2, 3.5);
        CAR_ASSETS.roofGeo.userData.shared = true;
        CAR_ASSETS.wheelGeo = new THREE.CylinderGeometry(1, 1, 0.5, 12);
        CAR_ASSETS.wheelGeo.userData.shared = true;
        CAR_ASSETS.headlightGeo = new THREE.SphereGeometry(0.4, 8, 8);
        CAR_ASSETS.headlightGeo.userData.shared = true;
        CAR_ASSETS.wheelMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
        CAR_ASSETS.wheelMat.userData.shared = true;
        CAR_ASSETS.headlightMat = new THREE.MeshStandardMaterial({
          color: 0xffffcc,
          emissive: 0xffffcc,
          emissiveIntensity: 0.5
        });
        CAR_ASSETS.headlightMat.userData.shared = true;
        CAR_ASSETS.tailMat = new THREE.MeshStandardMaterial({
          color: 0xff0000,
          emissive: 0xff0000,
          emissiveIntensity: 0.3
        });
        CAR_ASSETS.tailMat.userData.shared = true;
      }
      return CAR_ASSETS;
    }

    function getCarBodyMaterial(color) {
      const assets = getSharedCarAssets();
      if (assets.bodyMats.has(color)) return assets.bodyMats.get(color);
      const mat = new THREE.MeshStandardMaterial({
        color,
        metalness: 0.6,
        roughness: 0.4
      });
      mat.userData.shared = true;
      assets.bodyMats.set(color, mat);
      return mat;
    }
    
    function createCars() {
      // Create several cars on different roads
      const carSpecs = [
        { nx: 0.45, nz: 0.22, dir: 1, speed: 0.3, color: 0xff3333 },
        { nx: 0.55, nz: 0.44, dir: -1, speed: 0.25, color: 0x3333ff },
        { nx: 0.75, nz: 0.56, dir: 1, speed: 0.35, color: 0x33ff33 },
        { nx: 0.85, nz: 0.32, dir: -1, speed: 0.28, color: 0xffff33 },
        { nx: 0.60, nz: 0.70, dir: 1, speed: 0.32, color: 0xff33ff },
        { nx: 0.50, nz: 0.06, dir: 1, speed: 0.22, color: 0x33ffff },
      ];
      
      carSpecs.forEach(spec => {
        const car = createCar(spec.color);
        const [x, z] = toWorld(spec.nx, spec.nz);
        car.position.set(x, 1.5, z);
        car.userData.direction = spec.dir;
        car.userData.speed = spec.speed;
        car.userData.roadZ = z;
        car.userData.minX = toWorld(0.42, 0)[0];
        car.userData.maxX = toWorld(0.95, 0)[0];
        if (spec.dir < 0) car.rotation.y = Math.PI;
        LAYERS.props.add(car);
        cars.push(car);
      });
    }
    
    function createCar(color, options = {}) {
      const group = new THREE.Group();
      const isBlueprintCar = !!options.blueprintTraffic;
      const assets = getSharedCarAssets();
      
      // Car body
      const bodyMat = getCarBodyMaterial(color);
      const body = new THREE.Mesh(assets.bodyGeo, bodyMat);
      body.position.y = 1.5;
      body.castShadow = true;
      group.add(body);
      
      // Car roof
      const roof = new THREE.Mesh(assets.roofGeo, bodyMat);
      roof.position.set(-0.5, 3.5, 0);
      roof.castShadow = true;
      group.add(roof);
      
      // Wheels
      const wheelPositions = [
        [2.5, 0.5, 2.2], [2.5, 0.5, -2.2],
        [-2.5, 0.5, 2.2], [-2.5, 0.5, -2.2]
      ];
      wheelPositions.forEach(([x, y, z]) => {
        const wheel = new THREE.Mesh(assets.wheelGeo, assets.wheelMat);
        wheel.position.set(x, y, z);
        wheel.rotation.x = Math.PI / 2;
        wheel.castShadow = false;  // Decorative - no shadow
        group.add(wheel);
      });
      
      // Headlights (front)
      const hl1 = new THREE.Mesh(assets.headlightGeo, assets.headlightMat);
      const hl2 = new THREE.Mesh(assets.headlightGeo, assets.headlightMat);
      hl1.position.set(4.1, 1.5, 1.2);
      hl2.position.set(4.1, 1.5, -1.2);
      hl1.userData.isHeadlight = true;
      hl2.userData.isHeadlight = true;
      hl1.userData.blueprintTraffic = isBlueprintCar;
      hl2.userData.blueprintTraffic = isBlueprintCar;
      group.add(hl1, hl2);
      headlights.push(hl1, hl2);
      
      // Taillights (back) 
      const tl1 = new THREE.Mesh(assets.headlightGeo, assets.tailMat);
      const tl2 = new THREE.Mesh(assets.headlightGeo, assets.tailMat);
      tl1.position.set(-4.1, 1.5, 1.2);
      tl2.position.set(-4.1, 1.5, -1.2);
      group.add(tl1, tl2);
      
      return group;
    }
    
    function animateCars() {
      cars.forEach(car => {
        car.position.x += car.userData.direction * car.userData.speed;
        
        // Wrap around when reaching road ends
        if (car.position.x > car.userData.maxX) {
          car.position.x = car.userData.minX;
        } else if (car.position.x < car.userData.minX) {
          car.position.x = car.userData.maxX;
        }
      });
    }
    
    // Create street lamps
    function createStreetLamps() {
      const lampPositions = [];
      
      // Along main roads
      for (let x = 0.42; x < 0.95; x += 0.08) {
        lampPositions.push([x, 0.06], [x, 0.28], [x, 0.56]);
      }
      
      lampPositions.forEach(pos => {
        const [x, z] = toWorld(pos[0], pos[1]);
        const lamp = createStreetLamp();
        lamp.position.set(x, 0, z);
        LAYERS.props.add(lamp);
      });
    }
    
    function createStreetLamp() {
      const group = new THREE.Group();
      
      const poleMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
      const poleGeo = new THREE.CylinderGeometry(0.3, 0.4, 12, 6);
      const pole = new THREE.Mesh(poleGeo, poleMat);
      pole.position.y = 6;
      group.add(pole);
      
      // Arm
      const armGeo = new THREE.BoxGeometry(4, 0.3, 0.3);
      const arm = new THREE.Mesh(armGeo, poleMat);
      arm.position.set(2, 12, 0);
      group.add(arm);
      
      // Light
      const lightGeo = new THREE.SphereGeometry(1, 8, 8);
      const lightMat = new THREE.MeshStandardMaterial({ 
        color: 0xffffcc,
        emissive: 0x444422,
        emissiveIntensity: 0.5
      });
      const light = new THREE.Mesh(lightGeo, lightMat);
      light.position.set(4, 11.5, 0);
      light.userData.isStreetLight = true;
      group.add(light);
      streetLightBulbs.push(light);
      
      return group;
    }
    
    // Electric pylons for utility area
    function createElectricPylons() {
      const [cx, cz] = toWorld(0.945, 0.60);
      
      for (let i = 0; i < 3; i++) {
        const pylon = createPylon();
        pylon.position.set(cx, 0, cz - 30 + i * 30);
        LAYERS.props.add(pylon);
      }
    }
    
    function createPylon() {
      const group = new THREE.Group();
      const mat = new THREE.MeshStandardMaterial({ color: 0x606060 });
      
      // Main tower
      const towerGeo = new THREE.CylinderGeometry(1, 2, 50, 4);
      const tower = new THREE.Mesh(towerGeo, mat);
      tower.position.y = 25;
      group.add(tower);
      
      // Cross arms
      for (let y of [40, 30, 20]) {
        const armGeo = new THREE.BoxGeometry(20, 1, 1);
        const arm = new THREE.Mesh(armGeo, mat);
        arm.position.y = y;
        group.add(arm);
      }
      
      return group;
    }
    
    // Water treatment tanks
    function createWaterTreatment() {
      const [cx, cz] = toWorld(0.945, 0.85);
      
      const tankMat = new THREE.MeshStandardMaterial({ color: 0x888899 });
      
      for (let i = 0; i < 3; i++) {
        const tankGeo = new THREE.CylinderGeometry(12, 12, 8, 32);
        const tank = new THREE.Mesh(tankGeo, tankMat);
        tank.position.set(cx - 20 + i * 20, 5, cz);
        tank.castShadow = false;  // Small utility - no shadow
        LAYERS.props.add(tank);
        
        // Water inside
        const waterGeo = new THREE.CylinderGeometry(11, 11, 2, 32);
        const waterMat = new THREE.MeshStandardMaterial({ 
          color: 0x4488aa,
          roughness: 0.2
        });
        const water = new THREE.Mesh(waterGeo, waterMat);
        water.position.set(cx - 20 + i * 20, 8, cz);
        LAYERS.props.add(water);
      }
    }
    
    function createPondAt(x, z) {
      const pondGeo = new THREE.CircleGeometry(15, 32);
      pondGeo.rotateX(-Math.PI / 2);
      const pondMat = new THREE.MeshStandardMaterial({ 
        color: 0x4488aa,
        roughness: 0.3,
        metalness: 0.5
      });
      const pond = new THREE.Mesh(pondGeo, pondMat);
      pond.position.set(x, 1.5, z);
      LAYERS.props.add(pond);
    }
    
    // Create boats for port area
    function createPortBoatsAt(portX, portZ) {
      // Create port water basin (darker blue) - sits below ground level
      const basinGeo = new THREE.BoxGeometry(120, 6, 80);
      const basinMat = new THREE.MeshStandardMaterial({ 
        color: 0x2a5578,
        roughness: 0.2,
        metalness: 0.5
      });
      const basin = new THREE.Mesh(basinGeo, basinMat);
      basin.position.set(portX, -2, portZ);
      LAYERS.terrain.add(basin);
      
      // Docks (wooden platforms) - at water level
      const dockMat = new THREE.MeshStandardMaterial({ color: 0x7b5b3b });
      
      // Main dock along north edge of port
      const dock1 = new THREE.Mesh(new THREE.BoxGeometry(100, 2, 8), dockMat);
      dock1.position.set(portX, 0.5, portZ - 35);
      dock1.castShadow = false;  // Decorative - no shadow
      LAYERS.props.add(dock1);
      
      // West dock
      const dock2 = new THREE.Mesh(new THREE.BoxGeometry(8, 2, 60), dockMat);
      dock2.position.set(portX - 50, 0.5, portZ);
      dock2.castShadow = false;  // Decorative - no shadow
      LAYERS.props.add(dock2);
      
      // East dock
      const dock3 = new THREE.Mesh(new THREE.BoxGeometry(8, 2, 60), dockMat);
      dock3.position.set(portX + 50, 0.5, portZ);
      dock3.castShadow = false;  // Decorative - no shadow
      LAYERS.props.add(dock3);
      
      // Boats moored at docks - floating on water
      const boatPositions = [
        [portX - 25, portZ - 5, 0],
        [portX + 20, portZ, Math.PI * 0.1],
        [portX - 35, portZ + 20, Math.PI * 0.5],
        [portX + 35, portZ + 15, -Math.PI * 0.2],
        [portX, portZ + 25, Math.PI * 0.7]
      ];
      
      boatPositions.forEach(([bx, bz, rot], i) => {
        const boat = createBoat(i);
        boat.position.set(bx, 0, bz); // At water level
        boat.rotation.y = rot;
        boat.scale.setScalar(1.2);
        LAYERS.props.add(boat);
      });
    }
    
    function createBoat(type) {
      const group = new THREE.Group();
      
      // Hull - larger and more visible
      const hullShape = new THREE.Shape();
      hullShape.moveTo(-15, 0);
      hullShape.quadraticCurveTo(-15, 5, -12, 8);
      hullShape.lineTo(12, 8);
      hullShape.quadraticCurveTo(18, 5, 12, 0);
      hullShape.lineTo(-12, 0);
      
      const hullGeo = new THREE.ExtrudeGeometry(hullShape, {
        depth: 8,
        bevelEnabled: false
      });
      hullGeo.rotateX(-Math.PI / 2);
      
      const hullColors = [0x2244aa, 0xaa2222, 0x22aa22, 0xaaaa22];
      const hullMat = new THREE.MeshStandardMaterial({ 
        color: hullColors[type % hullColors.length] 
      });
      const hull = new THREE.Mesh(hullGeo, hullMat);
      hull.position.y = -2;
      group.add(hull);
      
      // Cabin
      const cabinGeo = new THREE.BoxGeometry(10, 8, 6);
      const cabinMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
      const cabin = new THREE.Mesh(cabinGeo, cabinMat);
      cabin.position.set(-2, 6, 0);
      group.add(cabin);
      
      return group;
    }
    
    // Add hotel star decorations
    function createHotelStarsAt(worldPositions) {
      worldPositions.forEach(([x, z]) => {
        const star = createStar();
        star.position.set(x, 60, z);
        LAYERS.props.add(star);
      });
    }
    
    function createStar() {
      const group = new THREE.Group();
      
      // Create 5-pointed star
      const starShape = new THREE.Shape();
      const outerR = 5;
      const innerR = 2;
      
      for (let i = 0; i < 10; i++) {
        const r = i % 2 === 0 ? outerR : innerR;
        const angle = (i / 10) * Math.PI * 2 - Math.PI / 2;
        const x = Math.cos(angle) * r;
        const y = Math.sin(angle) * r;
        
        if (i === 0) starShape.moveTo(x, y);
        else starShape.lineTo(x, y);
      }
      starShape.closePath();
      
      const starGeo = new THREE.ExtrudeGeometry(starShape, {
        depth: 2,
        bevelEnabled: false
      });
      
      const starMat = new THREE.MeshStandardMaterial({ 
        color: 0xffdd00,
        emissive: 0x664400,
        metalness: 0.8,
        roughness: 0.2
      });
      const star = new THREE.Mesh(starGeo, starMat);
      group.add(star);
      
      return group;
    }
    
    // Town Hall (Mairie) with classical columns
    function createTownHall(x, z) {
      const group = new THREE.Group();
      
      // Main building
      const mainGeo = new THREE.BoxGeometry(50, 30, 35);
      const mainMat = new THREE.MeshStandardMaterial({ color: 0xa88b6b });
      const main = new THREE.Mesh(mainGeo, mainMat);
      main.position.set(0, 16, 0);
      main.castShadow = true;
      group.add(main);
      
      // Triangular pediment
      const pedimentShape = new THREE.Shape();
      pedimentShape.moveTo(-25, 0);
      pedimentShape.lineTo(0, 15);
      pedimentShape.lineTo(25, 0);
      pedimentShape.closePath();
      
      const pedimentGeo = new THREE.ExtrudeGeometry(pedimentShape, {
        depth: 5,
        bevelEnabled: false
      });
      const pediment = new THREE.Mesh(pedimentGeo, mainMat);
      pediment.position.set(0, 31, 15);
      pediment.castShadow = true;
      group.add(pediment);
      
      // Columns
      const columnMat = new THREE.MeshStandardMaterial({ color: 0xddccbb });
      for (let i = 0; i < 6; i++) {
        const columnGeo = new THREE.CylinderGeometry(1.5, 2, 24, 12);
        const column = new THREE.Mesh(columnGeo, columnMat);
        column.position.set(-20 + i * 8, 13, 18);
        column.castShadow = true;
        group.add(column);
      }
      
      // Steps
      for (let i = 0; i < 4; i++) {
        const stepGeo = new THREE.BoxGeometry(50 + i * 4, 1.5, 8 - i * 1.5);
        const step = new THREE.Mesh(stepGeo, columnMat);
        step.position.set(0, 0.75 + i * 1.5, 20 + i * 1);
        group.add(step);
      }
      
      // Flag pole
      const poleGeo = new THREE.CylinderGeometry(0.3, 0.3, 20, 8);
      const poleMat = new THREE.MeshStandardMaterial({ color: 0x404040 });
      const pole = new THREE.Mesh(poleGeo, poleMat);
      pole.position.set(0, 56, 0);
      group.add(pole);
      
      // Flag
      const flagGeo = new THREE.PlaneGeometry(10, 6);
      const flagMat = new THREE.MeshStandardMaterial({ 
        color: 0x0055aa, 
        side: THREE.DoubleSide 
      });
      const flag = new THREE.Mesh(flagGeo, flagMat);
      flag.position.set(5, 60, 0);
      group.add(flag);
      
      group.position.set(x, 1, z);
      return group;
    }
    
    // Cinema with marquee
    function createCinema(x, z) {
      const group = new THREE.Group();
      
      // Main building
      const mainGeo = new THREE.BoxGeometry(35, 25, 30);
      const mainMat = new THREE.MeshStandardMaterial({ color: 0x8b7088 });
      const main = new THREE.Mesh(mainGeo, mainMat);
      main.position.set(0, 13.5, 0);
      main.castShadow = true;
      group.add(main);
      
      // Marquee (protruding entrance)
      const marqueeGeo = new THREE.BoxGeometry(25, 8, 6);
      const marqueeMat = new THREE.MeshStandardMaterial({ 
        color: 0xdd4444,
        emissive: 0x441111
      });
      const marquee = new THREE.Mesh(marqueeGeo, marqueeMat);
      marquee.position.set(0, 5, 18);
      marquee.castShadow = true;
      group.add(marquee);
      
      // Sign board
      const signGeo = new THREE.BoxGeometry(30, 10, 1);
      const signMat = new THREE.MeshStandardMaterial({ 
        color: 0xffee88,
        emissive: 0x554411
      });
      const sign = new THREE.Mesh(signGeo, signMat);
      sign.position.set(0, 30, 15.5);
      group.add(sign);
      
      // Decorative lights around marquee
      const lightMat = new THREE.MeshStandardMaterial({ 
        color: 0xffffaa,
        emissive: 0xffff44,
        emissiveIntensity: 0.5
      });
      
      for (let i = 0; i < 8; i++) {
        const lightGeo = new THREE.SphereGeometry(0.5, 8, 8);
        const light = new THREE.Mesh(lightGeo, lightMat);
        light.position.set(-10.5 + i * 3, 9, 18.5);
        light.userData.isMarqueeLight = true;
        group.add(light);
        marqueeLights.push(light);
      }
      
      group.position.set(x, 1, z);
      return group;
    }
    
    // Skyscraper with glass facade
    function createSkyscraper(x, z) {
      const group = new THREE.Group();
      
      const towerHeight = 280; // Much taller
      const towerWidth = 45;
      
      // Main tower - glass and steel facade
      const towerGeo = new THREE.BoxGeometry(towerWidth, towerHeight, towerWidth);
      const towerMat = new THREE.MeshStandardMaterial({ 
        color: 0x2f4763,
        metalness: 0.55,
        roughness: 0.25,
        envMapIntensity: 1.2
      });
      const tower = new THREE.Mesh(towerGeo, towerMat);
      tower.position.set(0, towerHeight / 2, 0);
      tower.castShadow = true;
      group.add(tower);
      
      // Reflective glass windows in grid pattern - INSTANCED
      const winMats = WINDOW_MATS;

      // geometry for skyscraper windows (keep your sizing)
      const floorHeight = 5;
      const floors = Math.floor(towerHeight / floorHeight);
      const windowsPerFloor = 4;
      const windowWidth = (towerWidth - 8) / windowsPerFloor;
      const wGeoFB = new THREE.PlaneGeometry(windowWidth - 1, floorHeight - 1);

      const litMatrices = [];
      const darkMatrices = [];

      for (let floor = 1; floor < floors; floor += 2) {
        const y = floor * floorHeight + 2;

        for (let w = 0; w < windowsPerFloor; w++) {
          const offset = -towerWidth/2 + 4 + w * windowWidth + windowWidth/2;
          const windowLit = rng() > 0.3;

          // Front (+Z)
          _tmpObj.position.set(offset, y, towerWidth/2 + 0.1);
          _tmpObj.rotation.set(0, 0, 0);
          _tmpObj.updateMatrix();
          (windowLit ? litMatrices : darkMatrices).push(_tmpObj.matrix.clone());

          // Back (-Z)
          _tmpObj.position.set(offset, y, -towerWidth/2 - 0.1);
          _tmpObj.rotation.set(0, Math.PI, 0);
          _tmpObj.updateMatrix();
          (windowLit ? litMatrices : darkMatrices).push(_tmpObj.matrix.clone());

          // Left (-X)
          _tmpObj.position.set(-towerWidth/2 - 0.1, y, offset);
          _tmpObj.rotation.set(0, -Math.PI/2, 0);
          _tmpObj.updateMatrix();
          (windowLit ? litMatrices : darkMatrices).push(_tmpObj.matrix.clone());

          // Right (+X)
          _tmpObj.position.set(towerWidth/2 + 0.1, y, offset);
          _tmpObj.rotation.set(0, Math.PI/2, 0);
          _tmpObj.updateMatrix();
          (windowLit ? litMatrices : darkMatrices).push(_tmpObj.matrix.clone());
        }
      }

      const lit = litMatrices.length ? makeInstanced(wGeoFB, winMats.day, litMatrices) : null;
      const dark = darkMatrices.length ? makeInstanced(wGeoFB, winMats.day, darkMatrices) : null;
      if (lit) group.add(lit);
      if (dark) group.add(dark);
      skyscraperWindowBatches.push({ lit, dark });
      
      // Horizontal steel bands
      const bandMat = new THREE.MeshStandardMaterial({ 
        color: 0x556677,
        metalness: 0.9,
        roughness: 0.3
      });
      
      for (let i = 0; i < floors; i += 5) {
        const bandGeo = new THREE.BoxGeometry(towerWidth + 1, 1, towerWidth + 1);
        const band = new THREE.Mesh(bandGeo, bandMat);
        band.position.set(0, i * floorHeight + 0.5, 0);
        group.add(band);
      }
      
      // Tapered top section
      const topGeo = new THREE.BoxGeometry(35, 30, 35);
      const top = new THREE.Mesh(topGeo, towerMat);
      top.position.set(0, towerHeight + 15, 0);
      top.castShadow = true;
      group.add(top);
      
      // Spire
      const spireGeo = new THREE.ConeGeometry(4, 50, 8);
      const spireMat = new THREE.MeshStandardMaterial({ 
        color: 0xdddddd,
        metalness: 0.95,
        roughness: 0.1
      });
      const spire = new THREE.Mesh(spireGeo, spireMat);
      spire.position.set(0, towerHeight + 55, 0);
      spire.castShadow = true;
      group.add(spire);
      
      // Aircraft warning lights (multiple)
      const warningPositions = [
        [0, towerHeight + 78, 0],
        [15, towerHeight - 20, 15],
        [-15, towerHeight - 20, -15]
      ];
      
      warningPositions.forEach(([wx, wy, wz]) => {
        const warningLight = new THREE.Mesh(
          new THREE.SphereGeometry(2, 8, 8),
          new THREE.MeshStandardMaterial({ 
            color: 0xff0000,
            emissive: 0xff0000,
            emissiveIntensity: 1
          })
        );
        warningLight.position.set(wx, wy, wz);
        warningLight.userData.isWarningLight = true;
        group.add(warningLight);
        warningLights.push(warningLight);
      });
      
      group.position.set(x, 1, z);
      return group;
    }
    
    // School building with bell tower for zones with hasSchool
    function createSchool(x, z) {
      const group = new THREE.Group();
      
      // Main building
      const mainGeo = new THREE.BoxGeometry(30, 20, 25);
      const mainMat = new THREE.MeshStandardMaterial({ color: 0xc87878 });
      const main = new THREE.Mesh(mainGeo, mainMat);
      main.position.set(0, 11, 0);
      main.castShadow = true;
      group.add(main);
      
      // Bell tower
      const towerGeo = new THREE.BoxGeometry(8, 15, 8);
      const tower = new THREE.Mesh(towerGeo, mainMat);
      tower.position.set(0, 28, 0);
      tower.castShadow = true;
      group.add(tower);
      
      // Bell tower roof
      const roofGeo = new THREE.ConeGeometry(6, 8, 4);
      const roofMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
      const roof = new THREE.Mesh(roofGeo, roofMat);
      roof.position.set(0, 39, 0);
      roof.rotation.y = Math.PI / 4;
      roof.castShadow = true;
      group.add(roof);
      
      // Windows
      const windowMat = new THREE.MeshStandardMaterial({ 
        color: 0x88ccff,
        emissive: 0x112233
      });
      const windowGeo = new THREE.PlaneGeometry(4, 5);
      
      for (let floor = 0; floor < 2; floor++) {
  for (let i = 0; i < 4; i++) {
          const w1 = new THREE.Mesh(windowGeo, windowMat);
          w1.position.set(-10 + i * 7, 8 + floor * 8, 12.6);
          group.add(w1);
          
          const w2 = new THREE.Mesh(windowGeo, windowMat);
          w2.position.set(-10 + i * 7, 8 + floor * 8, -12.6);
          w2.rotation.y = Math.PI;
          group.add(w2);
        }
      }
      
      group.position.set(x, 1, z);
      return group;
    }
    
    // OLD addWindows function removed - windows now attached to building groups
    
    // ============================================
    // WATER ANIMATION - Fixed to stay in sea bounds
    // ============================================
    
    let waterMesh;
    let waterOriginalPositions = [];
    let waterNormalCounter = 0;
    let waterFrame = 0;
    
    function createAnimatedWater() {
      // Create water only for the sea area (left side of map)
      // Use shape to match sea boundary
      const seaShape = new THREE.Shape();
      const seaWorldPts = seaPoints.map(([nx, nz]) => toWorld(nx, nz));
      seaShape.moveTo(seaWorldPts[0][0], -seaWorldPts[0][1]);
      for (let i = 1; i < seaWorldPts.length; i++) {
        seaShape.lineTo(seaWorldPts[i][0], -seaWorldPts[i][1]);
      }
      seaShape.closePath();
      
      const waterGeo = new THREE.ShapeGeometry(seaShape, 8);  // Reduced from 32
      waterGeo.rotateX(-Math.PI / 2);
      
      const waterMat = new THREE.MeshStandardMaterial({
        color: COLORS.sea,
        roughness: 0.2,
        metalness: 0.5,
        transparent: true,
        opacity: 0.95
      });
      
      waterMesh = new THREE.Mesh(waterGeo, waterMat);
      waterMesh.position.y = -1;
      
      // Store original positions for wave animation
      const positions = waterMesh.geometry.attributes.position;
      for (let i = 0; i < positions.count; i++) {
        waterOriginalPositions.push({
          x: positions.getX(i),
          y: positions.getY(i),
          z: positions.getZ(i)
        });
      }
      
      LAYERS.terrain.add(waterMesh);
      return waterMesh;
    }
    
    function animateWater(time) {
      if (blueprintCityEnabled) return;
      if (!waterMesh || waterOriginalPositions.length === 0) return;
      
      // Skip work on most frames (cuts CPU cost a lot)
      waterFrame++;
      if (waterFrame % 3 !== 0) return;
      
      const positions = waterMesh.geometry.attributes.position;
      for (let i = 0; i < positions.count; i++) {
        const orig = waterOriginalPositions[i];
        // Gentle wave motion - Y is up in the rotated geometry
        const waveHeight = Math.sin(orig.x * 0.01 + time * 0.5) * 2 + 
                          Math.cos(orig.z * 0.01 + time * 0.3) * 1.5;
        positions.setY(i, orig.y + waveHeight);
      }
      positions.needsUpdate = true;
      waterNormalCounter++;
      if (waterNormalCounter % 60 === 0) {  // Reduced from every 5 frames
        waterMesh.geometry.computeVertexNormals();
      }
    }
    
    // ============================================
    // UI & CONTROLS
    // ============================================
    
    let isNight = false;
    let fidelityModeActive = false;
    let animationEnabled = true;
    const PERF_LOGGING = false;
    const fidelityState = {
      shadowEnabled: renderer.shadowMap.enabled,
      toneMappingExposure: renderer.toneMappingExposure,
      propsVisible: LAYERS.props.visible,
      fxVisible: LAYERS.fx.visible
    };

    function setCityLayerVisibility() {
      const showLegacy = !blueprintCityEnabled && !editorState.hideCity;
      const showBlueprint = blueprintCityEnabled && !editorState.hideCity;
      const showProps = !fidelityModeActive;

      LAYERS.terrain.visible = showLegacy;
      LAYERS.zones.visible = showLegacy;
      LAYERS.roads.visible = showLegacy;
      LAYERS.buildings.visible = showLegacy;
      LAYERS.props.visible = showLegacy && showProps;
      LAYERS.fx.visible = showLegacy && showProps;

      BLUEPRINT_LAYERS.terrain.visible = showBlueprint;
      BLUEPRINT_LAYERS.zones.visible = showBlueprint;
      BLUEPRINT_LAYERS.roads.visible = showBlueprint;
      BLUEPRINT_LAYERS.buildings.visible = showBlueprint;
      BLUEPRINT_LAYERS.props.visible = showBlueprint && showProps;
      BLUEPRINT_LAYERS.fx.visible = showBlueprint && showProps;
    }

    function applyFidelityShading() {
      ambientLight.intensity = 0.85;
      sunLight.intensity = 0.2;
      hemisphereLight.intensity = 0.1;
    }

    function applyFidelityMode(enabled) {
      const wasActive = fidelityModeActive;
      fidelityModeActive = enabled;
      if (enabled) {
        if (!wasActive) {
          fidelityState.shadowEnabled = renderer.shadowMap.enabled;
          fidelityState.toneMappingExposure = renderer.toneMappingExposure;
        }

        renderer.shadowMap.enabled = false;
        renderer.toneMappingExposure = 1.0;
        applyFidelityShading();
      } else if (wasActive) {
        renderer.shadowMap.enabled = fidelityState.shadowEnabled;
        renderer.toneMappingExposure = fidelityState.toneMappingExposure;
        setTimeOfDay(isNight);
      }
      setCityLayerVisibility();
    }
    
    function updateOverlayVisibility() {
      if (!mapOverlayGroup || !mapOverlayMesh) return;
      const toggle = document.getElementById('overlayToggle');
      const allowed = (viewMode === 'plan' || viewMode === 'fidelity');
      const visible = overlaySettings?.visible ?? true;
      const isVisible = allowed && visible;
      mapOverlayMesh.visible = isVisible;
      if (overlayDimmer) overlayDimmer.visible = isVisible;
      if (toggle) toggle.checked = !!visible;
      updateDebugVisibility();
    }
    
    // Keyboard controls (arrow keys for camera movement)
    const keyState = { ArrowLeft: false, ArrowRight: false, ArrowUp: false, ArrowDown: false };
    
    window.addEventListener('keydown', (e) => {
      if (e.key in keyState) {
        keyState[e.key] = true;
        e.preventDefault();
      }
    });
    
    window.addEventListener('keyup', (e) => {
      if (e.key in keyState) {
        keyState[e.key] = false;
        e.preventDefault();
      }
    });
    
    const viewModeController = createViewModeController({
      getViewMode: () => viewMode,
      setViewModeValue: (mode) => { viewMode = mode; },
      cameras: { orthoCamera, perspCamera, setActiveCamera },
      controls,
      applyFidelityMode,
      updateOverlayVisibility,
      updateEditorStatus,
      editorState,
      editorGroup,
      setCityLayerVisibility
    });
    const setViewMode = (mode) => viewModeController.setViewMode(mode);
    
    function setTimeOfDay(night) {
      isNight = night;
      
      document.getElementById('btnDay').classList.toggle('active', !night);
      document.getElementById('btnNight').classList.toggle('active', night);
      
      if (night) {
        scene.background = new THREE.Color(0x0a1020);
        ambientLight.intensity = 0.15;
        sunLight.intensity = 0.1;
        sunLight.color.setHex(0x8888ff);
        hemisphereLight.intensity = 0.1;
        
        // Instanced building windows
        buildingWindowBatches.forEach(b => {
          if (b.lit)  b.lit.material  = WINDOW_MATS.nightLit;
          if (b.dark) b.dark.material = WINDOW_MATS.nightDark;
        });
        
        // Instanced skyscraper windows
        skyscraperWindowBatches.forEach(b => {
          if (b.lit)  b.lit.material  = WINDOW_MATS.nightLit;
          if (b.dark) b.dark.material = WINDOW_MATS.nightDark;
        });
        
        // Street lights glow at night
        streetLightBulbs.forEach(b => {
          b.material.emissive.setHex(0xffff88);
          b.material.emissiveIntensity = 2;
        });
        
        // Car headlights bright at night
        headlights.forEach(h => {
          h.material.emissive.setHex(0xffffee);
          h.material.emissiveIntensity = 3;
        });
      } else {
        scene.background = new THREE.Color(0x88bbdd);
        ambientLight.intensity = 0.5;
        sunLight.intensity = 1.2;
        sunLight.color.setHex(0xffeedd);
        hemisphereLight.intensity = 0.3;
        
        // Instanced building windows
        buildingWindowBatches.forEach(b => {
          if (b.lit)  b.lit.material  = WINDOW_MATS.day;
          if (b.dark) b.dark.material = WINDOW_MATS.day;
        });
        
        // Instanced skyscraper windows
        skyscraperWindowBatches.forEach(b => {
          if (b.lit)  b.lit.material  = WINDOW_MATS.day;
          if (b.dark) b.dark.material = WINDOW_MATS.day;
        });
        
        // Street lights dim during day
        streetLightBulbs.forEach(b => {
          b.material.emissiveIntensity = 0.3;
        });
        
        // Car headlights dim during day
        headlights.forEach(h => {
          h.material.emissiveIntensity = 0.3;
        });
      }

      if (fidelityModeActive) {
        applyFidelityShading();
      }
    }

    function setAnimationEnabled(enabled) {
      animationEnabled = !!enabled;
      const btn = document.getElementById('btnAnim');
      if (btn) {
        btn.classList.toggle('active', animationEnabled);
        btn.textContent = animationEnabled ? 'On' : 'Off';
      }
    }
    
    // Event listeners
    document.getElementById('btnPlan').addEventListener('click', () => setViewMode('plan'));
    document.getElementById('btn3D').addEventListener('click', () => setViewMode('3d'));
    document.getElementById('btnStreet').addEventListener('click', () => setViewMode('street'));
    document.getElementById('btnFidelity').addEventListener('click', () => setViewMode('fidelity'));
    document.getElementById('btnDay').addEventListener('click', () => setTimeOfDay(false));
    document.getElementById('btnNight').addEventListener('click', () => setTimeOfDay(true));
    document.getElementById('btnAnim').addEventListener('click', () => setAnimationEnabled(!animationEnabled));
    
    // Menu hide/show
    document.getElementById('btnHideUI').addEventListener('click', () => {
      document.getElementById('ui').classList.add('hidden');
    });

    const fidelityModal = document.getElementById('fidelityModal');
    const fidelityHelpBtn = document.getElementById('btnFidelityHelp');
    const fidelityHelpClose = document.getElementById('closeFidelityHelp');
    if (fidelityHelpBtn && fidelityModal && fidelityHelpClose) {
      fidelityHelpBtn.addEventListener('click', () => {
        fidelityModal.style.display = 'flex';
      });
      fidelityHelpClose.addEventListener('click', () => {
        fidelityModal.style.display = 'none';
      });
      fidelityModal.addEventListener('click', (e) => {
        if (e.target === fidelityModal) fidelityModal.style.display = 'none';
      });
    }

    const editorModal = document.getElementById('editorHelpModal');
    const editorHelpBtn = document.getElementById('btnEditorHelp');
    const editorHelpClose = document.getElementById('closeEditorHelp');
    if (editorHelpBtn && editorModal && editorHelpClose) {
      editorHelpBtn.addEventListener('click', () => {
        editorModal.style.display = 'flex';
      });
      editorHelpClose.addEventListener('click', () => {
        editorModal.style.display = 'none';
      });
      editorModal.addEventListener('click', (e) => {
        if (e.target === editorModal) editorModal.style.display = 'none';
      });
    }
    
    // Touch Controls - Virtual Joystick
    const joystick = document.getElementById('joystick');
    const joystickKnob = document.getElementById('joystickKnob');
    let joystickActive = false;
    let joystickOrigin = { x: 0, y: 0 };
    
    if (joystick && joystickKnob) {
      joystick.addEventListener('touchstart', (e) => {
        joystickActive = true;
        const rect = joystick.getBoundingClientRect();
        joystickOrigin = { 
          x: rect.left + rect.width / 2, 
          y: rect.top + rect.height / 2 
        };
        e.preventDefault();
      });
      
      joystick.addEventListener('touchmove', (e) => {
        if (!joystickActive) return;
        const touch = e.touches[0];
        const dx = touch.clientX - joystickOrigin.x;
        const dy = touch.clientY - joystickOrigin.y;
        const maxDist = 35;
        const dist = Math.min(Math.sqrt(dx*dx + dy*dy), maxDist);
        const angle = Math.atan2(dy, dx);
        
        const kx = Math.cos(angle) * dist;
        const ky = Math.sin(angle) * dist;
        
        joystickKnob.style.transform = `translate(calc(-50% + ${kx}px), calc(-50% + ${ky}px))`;
        
        // Apply to camera movement
        if (viewMode === '3d' || viewMode === 'street') {
          const moveSpeed = 2;
          const dxWorld = (kx / maxDist) * moveSpeed;
          const dzWorld = (ky / maxDist) * moveSpeed;
          perspCamera.position.x += dxWorld;
          perspCamera.position.z += dzWorld;
          controls.target.x += dxWorld;
          controls.target.z += dzWorld;
        }
        e.preventDefault();
      });
      
      joystick.addEventListener('touchend', () => {
        joystickActive = false;
        joystickKnob.style.transform = 'translate(-50%, -50%)';
      });
    }
    
    // Zoom controls (desktop only)
    const zoomIn = document.getElementById('zoomIn');
    const zoomOut = document.getElementById('zoomOut');
    const isCoarse = window.matchMedia('(pointer: coarse)').matches;
    
    if (!isCoarse && zoomIn && zoomOut) {
      zoomIn.addEventListener('click', () => {
        if (viewMode === '3d' || viewMode === 'street') {
          perspCamera.position.y = Math.max(50, perspCamera.position.y - 50);
          perspCamera.fov = Math.max(30, perspCamera.fov - 5);
          perspCamera.updateProjectionMatrix();
        }
      });
      
      zoomOut.addEventListener('click', () => {
        if (viewMode === '3d' || viewMode === 'street') {
          perspCamera.position.y = Math.min(800, perspCamera.position.y + 50);
          perspCamera.fov = Math.min(90, perspCamera.fov + 5);
          perspCamera.updateProjectionMatrix();
        }
      });
    }
    
    // Touch gesture support for the canvas
    let touchStartDist = 0;
    renderer.domElement.addEventListener('touchstart', (e) => {
      if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        touchStartDist = Math.sqrt(dx*dx + dy*dy);
      }
    });
    
    renderer.domElement.addEventListener('touchmove', (e) => {
      if (e.touches.length === 2 && viewMode !== 'plan') {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const delta = dist - touchStartDist;
        
        // Pinch zoom
        perspCamera.position.y -= delta * 0.5;
        perspCamera.position.y = Math.max(50, Math.min(800, perspCamera.position.y));
        
        touchStartDist = dist;
        e.preventDefault();
      }
    });
    
    // ============================================
    // COMPASS
    // ============================================
    
    const compassCanvas = document.getElementById('compass');
    const compassCtx = compassCanvas.getContext('2d');
    compassCanvas.width = 80;
    compassCanvas.height = 80;
    
    function drawCompass() {
      const ctx = compassCtx;
      const cx = 40, cy = 40, r = 35;
      
      ctx.clearRect(0, 0, 80, 80);
      
      // Background
      ctx.fillStyle = 'rgba(15, 15, 35, 0.8)';
      ctx.beginPath();
      ctx.arc(cx, cy, r + 3, 0, Math.PI * 2);
      ctx.fill();
      
      // Border
      ctx.strokeStyle = 'rgba(100, 200, 255, 0.5)';
      ctx.lineWidth = 1;
      ctx.stroke();
      
      // Directions
      ctx.fillStyle = '#64c8ff';
      ctx.font = 'bold 12px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      ctx.fillText('N', cx, cy - r + 10);
      ctx.fillStyle = '#aaa';
      ctx.fillText('S', cx, cy + r - 10);
      ctx.fillText('E', cx + r - 10, cy);
      ctx.fillText('W', cx - r + 10, cy);
      
      // Center dot
      ctx.fillStyle = '#64c8ff';
      ctx.beginPath();
      ctx.arc(cx, cy, 3, 0, Math.PI * 2);
      ctx.fill();
    }
    
    drawCompass();
    
    // ============================================
    // RAYCASTING FOR ZONE INFO
    // ============================================
    
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    
    function onMouseMove(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      
      raycaster.setFromCamera(mouse, activeCamera);
      const zonesToTest = blueprintCityEnabled ? blueprintZoneMeshes : zones;
      const intersects = raycaster.intersectObjects(zonesToTest);
      
      if (intersects.length > 0) {
        const zone = intersects[0].object;
        const data = zone.userData;
        if (data.label) {
          const info = getLegendInfo(data.label);
          document.getElementById('zoneInfo').textContent = 
            `${normalizeTypeCode(data.label)}: ${info.label || data.type}`;
        }
      } else {
        document.getElementById('zoneInfo').textContent = 'Hover over zones for info';
      }
    }
    
    window.addEventListener('mousemove', onMouseMove);
    
    // ============================================
    // PLACEMENT DEBUG TOOL
    // ============================================
    const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -1); // y=1 plane (zone level)
    const tmpP = new THREE.Vector3();
    
    window.addEventListener('pointerdown', (e) => {
      // Only log on left click (button 0) and when holding Shift
      if (e.button !== 0 || !e.shiftKey) return;
      
      mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, activeCamera);
      
      if (!raycaster.ray.intersectPlane(groundPlane, tmpP)) return;
      
      const x = tmpP.x;
      const z = tmpP.z;
      const nx = x / MAP_WIDTH + 0.5;
      const nz = z / MAP_HEIGHT + 0.5;
      
      const result = {
        world: { x: +x.toFixed(2), z: +z.toFixed(2) },
        normalized: { nx: +nx.toFixed(4), nz: +nz.toFixed(4) }
      };
      
      if (mapCoordMapper && mapOverlayGroup) {
        const pxCoords = overlayWorldToPx(x, z);
        if (pxCoords) {
          result.overlay = { px: +pxCoords.px.toFixed(1), py: +pxCoords.py.toFixed(1) };
          const inverse = overlayPxToWorld(pxCoords.px, pxCoords.py);
          if (inverse) result.inverse = { x: +inverse.x.toFixed(2), z: +inverse.z.toFixed(2) };
        }
      } else {
        result.warning = 'mapCoordMapper not ready';
      }
      
      console.log('PROBE', result);
      
      // Bonus: Move marker
      if (!probeMarker) {
        probeMarker = new THREE.Mesh(
          new THREE.SphereGeometry(3, 8, 8),
          new THREE.MeshStandardMaterial({ color: 0xff00ff, emissive: 0x440044 })
        );
        probeMarker.position.y = 5;
        scene.add(probeMarker);
      }
      probeMarker.position.set(x, 5, z);
      probeMarker.visible = true;
    });
    
    // ============================================
    // RESIZE HANDLER
    // ============================================
    
    window.addEventListener('resize', () => {
      const aspect = window.innerWidth / window.innerHeight;
      
      orthoCamera.left = -frustumSize * aspect / 2;
      orthoCamera.right = frustumSize * aspect / 2;
      orthoCamera.updateProjectionMatrix();
      
      perspCamera.aspect = aspect;
      perspCamera.updateProjectionMatrix();
      
      renderer.setSize(window.innerWidth, window.innerHeight);

      updateLineResolution(editorDraftLine);
      updateLineResolution(editorDraftGlowLine);
      updateLineResolution(editorSelectionLine);
      updateLineResolution(editorSelectionGlowLine);
      updateLineResolution(overlayBounds);
    });
    
    // ============================================
    // INITIALIZATION
    // ============================================
    
    async function init() {
      console.log("TADHG CITY SIMULATOR - VERSION 2.1 - ROBUST FIXES APPLIED");
      // Show loading progress
      const loadingBar = document.getElementById('loadingBar');
      
      loadingBar.style.width = '20%';

      try {
        loadOverlayImageFromStore();
        const migrationImageId = getOverlayImageId() || PERSISTENCE_IMAGE_ID;
        runMigrations({ imageId: migrationImageId });
      } catch (error) {
        console.warn('Failed to run migrations:', error);
      }
      
      // Phase 1: 2D Zones
      buildPhase1();
      loadingBar.style.width = '40%';
      
      // Phase 2: 3D Buildings
      setTimeout(async () => {
        buildPhase2();
        loadingBar.style.width = '70%';
        
        // Animated water
        createAnimatedWater();
        loadingBar.style.width = '80%';
        
        // Map overlay
        try {
          const uploadedDataUrl = getOverlayImageDataURL();
          const uploadedMeta = getOverlayImageMeta();
          mapOverlayImgW = uploadedMeta?.width || MAP_OVERLAY_IMG_W;
          mapOverlayImgH = uploadedMeta?.height || MAP_OVERLAY_IMG_H;

          mapOverlayGroup = new THREE.Group();
          mapOverlayGroup.name = 'MapOverlayGroup';
          LAYERS.overlay.add(mapOverlayGroup);

          overlayLayer = await createOverlayLayer({
            renderer,
            textureUrl: uploadedDataUrl || './Master_AI_MAP.png',
            imgW: mapOverlayImgW,
            imgH: mapOverlayImgH,
            worldW: MAP_OVERLAY_WORLD_W,
            worldH: MAP_OVERLAY_WORLD_H,
            y: Y.overlay,
            opacity: 0.9,
            visible: true,
            renderOnTop: false,
            dimmerOpacity: 0,
            overlayGroup: mapOverlayGroup,
            syncBlueprintRoot: syncBlueprintRootToOverlay,
            updateLineResolution,
            blueprintGroups: { overlayBounds }
          });

          mapOverlayMesh = overlayLayer.mapOverlayMesh;
          overlayDimmer = overlayLayer.overlayDimmer;
          mapCoordMapper = overlayLayer.mapCoordMapper;

          syncBlueprintRootToOverlay();
          exposeDebugState();
          applyOverlayCalibKey();

          // Setup overlay controls
          setupOverlayControls();
          setupDebugHelpers();
          setupDebugControls();
          setupBlueprintControls();
          setupEditorControls();
          bindEditorEvents();
          await loadBlueprintData();

          console.log('Map overlay loaded. coordMapper available for pixel-to-world conversion.');
        } catch (error) {
          console.warn('Failed to load map overlay:', error);
        }
        
        loadingBar.style.width = '90%';
        
        // Set initial view
        setTimeOfDay(false);
        setViewMode('plan');
        
        loadingBar.style.width = '100%';
        
        // Hide loading screen
        setTimeout(() => {
          document.getElementById('loading').style.opacity = '0';
          setTimeout(() => {
            document.getElementById('loading').style.display = 'none';
          }, 500);
        }, 300);
      }, 100);
    }
    
    function setupOverlayControls() {
      const toggle = document.getElementById('overlayToggle');
      const opacitySlider = document.getElementById('overlayOpacity');
      const opacityInput = document.getElementById('overlayOpacityValue');
      const dimmerSlider = document.getElementById('overlayDimmer');
      const dimmerInput = document.getElementById('overlayDimmerValue');
      const offsetXSlider = document.getElementById('overlayOffsetX');
      const offsetXInput = document.getElementById('overlayOffsetXValue');
      const offsetZSlider = document.getElementById('overlayOffsetZ');
      const offsetZInput = document.getElementById('overlayOffsetZValue');
      const rotationSlider = document.getElementById('overlayRotation');
      const rotationInput = document.getElementById('overlayRotationValue');
      const scaleSlider = document.getElementById('overlayScale');
      const scaleInput = document.getElementById('overlayScaleValue');
      const resetBtn = document.getElementById('overlayReset');
      const exportBtn = document.getElementById('overlayExport');
      const importBtn = document.getElementById('overlayImport');
      const jsonField = document.getElementById('overlayJson');
      const panelToggle = document.getElementById('overlayPanelToggle');
      const panel = document.getElementById('overlayControls');
      
      if (!toggle || !opacitySlider || !mapOverlayMesh || !mapOverlayGroup) return;
      
      const normalizeOverlaySettings = (raw = {}) => {
        const normalized = { ...OVERLAY_DEFAULTS };
        if (typeof raw.visible === 'boolean') normalized.visible = raw.visible;
        
        ['offsetX', 'offsetZ', 'rotation', 'scale', 'opacity', 'dimmer'].forEach(key => {
          const value = Number.parseFloat(raw[key]);
          if (Number.isFinite(value)) {
            const limit = OVERLAY_LIMITS[key];
            normalized[key] = clampNumber(value, limit.min, limit.max);
          }
        });
        
        return normalized;
      };
      
      const loadSettings = () => {
        try {
          applyOverlayCalibKey();
          const stored = getItem(PERSIST_KEYS.overlayCalib);
          if (stored) return normalizeOverlaySettings(stored);
        } catch (e) {
          console.warn('Failed to load overlay calibration:', e);
        }
        return { ...OVERLAY_DEFAULTS };
      };
      
      const saveSettings = () => {
        try {
          applyOverlayCalibKey();
          setItem(PERSIST_KEYS.overlayCalib, overlaySettings);
        } catch (e) {
          console.warn('Failed to save overlay calibration:', e);
        }
      };
      
      const applySettings = (settings, { syncInputs = true } = {}) => {
        mapOverlayGroup.position.set(settings.offsetX, 0, settings.offsetZ);
        mapOverlayGroup.rotation.set(0, THREE.MathUtils.degToRad(settings.rotation), 0);
        mapOverlayGroup.scale.set(settings.scale, 1, settings.scale);
        if (mapOverlayMesh.material) mapOverlayMesh.material.opacity = settings.opacity;
        if (overlayDimmer && overlayDimmer.material) overlayDimmer.material.opacity = settings.dimmer;
        syncBlueprintRootToOverlay();
        verifyOverlayMapping();
        
        if (!syncInputs) return;
        if (opacitySlider) opacitySlider.value = settings.opacity;
        if (opacityInput) opacityInput.value = settings.opacity;
        if (dimmerSlider) dimmerSlider.value = settings.dimmer;
        if (dimmerInput) dimmerInput.value = settings.dimmer;
        if (offsetXSlider) offsetXSlider.value = settings.offsetX;
        if (offsetXInput) offsetXInput.value = settings.offsetX;
        if (offsetZSlider) offsetZSlider.value = settings.offsetZ;
        if (offsetZInput) offsetZInput.value = settings.offsetZ;
        if (rotationSlider) rotationSlider.value = settings.rotation;
        if (rotationInput) rotationInput.value = settings.rotation;
        if (scaleSlider) scaleSlider.value = settings.scale;
        if (scaleInput) scaleInput.value = settings.scale;
      };
      
      const updateSetting = (key, value) => {
        if (!Number.isFinite(value)) return;
        const limit = OVERLAY_LIMITS[key];
        overlaySettings[key] = clampNumber(value, limit.min, limit.max);
        applySettings(overlaySettings, { syncInputs: true });
        saveSettings();
      };
      
      const bindDualInput = (key, slider, numberInput) => {
        if (slider) {
          slider.addEventListener('input', (e) => {
            updateSetting(key, Number.parseFloat(e.target.value));
          });
        }
        if (numberInput) {
          numberInput.addEventListener('input', (e) => {
            updateSetting(key, Number.parseFloat(e.target.value));
          });
        }
      };
      
      const stepInputs = [opacitySlider, offsetXSlider, offsetZSlider, rotationSlider, scaleSlider];
      if (dimmerSlider) stepInputs.push(dimmerSlider);
      const setFineSteps = (fine) => {
        stepInputs.forEach(input => {
          if (!input) return;
          const step = fine ? input.dataset.stepFine : input.dataset.step;
          if (step) input.step = step;
        });
      };
      
      window.addEventListener('keydown', (e) => {
        if (e.key === 'Shift') setFineSteps(true);
      });
      window.addEventListener('keyup', (e) => {
        if (e.key === 'Shift') setFineSteps(false);
      });
      
      overlaySettings = loadSettings();
      applySettings(overlaySettings, { syncInputs: true });
      updateOverlayVisibility();
      
      toggle.addEventListener('change', (e) => {
        overlaySettings.visible = !!e.target.checked;
        saveSettings();
        updateOverlayVisibility();
      });
      
      bindDualInput('opacity', opacitySlider, opacityInput);
      bindDualInput('dimmer', dimmerSlider, dimmerInput);
      bindDualInput('offsetX', offsetXSlider, offsetXInput);
      bindDualInput('offsetZ', offsetZSlider, offsetZInput);
      bindDualInput('rotation', rotationSlider, rotationInput);
      bindDualInput('scale', scaleSlider, scaleInput);
      
      if (resetBtn) {
        resetBtn.addEventListener('click', () => {
          overlaySettings = { ...OVERLAY_DEFAULTS };
          applySettings(overlaySettings, { syncInputs: true });
          saveSettings();
          updateOverlayVisibility();
          if (jsonField) jsonField.value = '';
        });
      }
      
      if (exportBtn) {
        exportBtn.addEventListener('click', () => {
          const json = JSON.stringify(overlaySettings);
          if (jsonField) jsonField.value = json;
          if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(json).then(() => {
              console.log('Calibration settings copied:', json);
            }).catch(e => {
              console.warn('Failed to copy:', e);
            });
          }
        });
      }
      
      if (importBtn) {
        importBtn.addEventListener('click', () => {
          const raw = jsonField ? jsonField.value.trim() : '';
          if (!raw) return;
          try {
            overlaySettings = normalizeOverlaySettings(JSON.parse(raw));
            applySettings(overlaySettings, { syncInputs: true });
            saveSettings();
            updateOverlayVisibility();
          } catch (e) {
            console.warn('Failed to import calibration:', e);
          }
        });
      }

      if (panelToggle && panel) {
        const applyPanelState = (collapsed) => {
          panel.classList.toggle('collapsed', collapsed);
          panelToggle.textContent = collapsed ? 'Show' : 'Hide';
        };
        let collapsed = false;
        try {
          const stored = getItem(PERSIST_KEYS.overlayPanelCollapsed);
          if (typeof stored === 'boolean') collapsed = stored;
        } catch (e) {
          collapsed = false;
        }
        applyPanelState(collapsed);
        panelToggle.addEventListener('click', () => {
          collapsed = !collapsed;
          applyPanelState(collapsed);
          try {
            setItem(PERSIST_KEYS.overlayPanelCollapsed, collapsed);
          } catch (e) {
            // ignore
          }
        });
      }
    }

    function setupDebugControls() {
      const gridToggle = document.getElementById('debugGrid');
      const boundsToggle = document.getElementById('debugOverlayBounds');
      const blueprintToggle = document.getElementById('debugBlueprintOutlines');
      const roadCenterToggle = document.getElementById('debugRoadCenterlines');

      const bindToggle = (toggle, key) => {
        if (!toggle) return;
        toggle.checked = !!debugSettings[key];
        toggle.addEventListener('change', (e) => {
          debugSettings[key] = !!e.target.checked;
          updateDebugVisibility();
        });
      };

      bindToggle(gridToggle, 'showGrid');
      bindToggle(boundsToggle, 'showOverlayBounds');
      bindToggle(blueprintToggle, 'showBlueprintOutlines');
      bindToggle(roadCenterToggle, 'showRoadCenterlines');
    }

    function setupBlueprintControls() {
      const loadBtn = document.getElementById('blueprintLoad');
      const saveBtn = document.getElementById('blueprintSave');
      const copyBtn = document.getElementById('blueprintCopy');
      const validateBtn = document.getElementById('blueprintValidate');
      const overlayUploadBtn = document.getElementById('overlayUpload');
      const jsonField = document.getElementById('blueprintJson');
      const useCityToggle = document.getElementById('blueprintUseCity');
      const opacitySlider = document.getElementById('blueprintOpacity');
      const opacityInput = document.getElementById('blueprintOpacityValue');
      const labelsToggle = document.getElementById('blueprintLabels');

      if (!loadBtn || !saveBtn || !copyBtn || !validateBtn || !jsonField) return;

      try {
        const storedOpacity = getItem(PERSIST_KEYS.blueprintOpacity);
        if (Number.isFinite(storedOpacity)) {
          blueprintPreviewSettings.opacity = clampNumber(storedOpacity, 0.1, 1);
        }
        const storedLabels = getItem(PERSIST_KEYS.blueprintShowLabels);
        if (typeof storedLabels === 'boolean') {
          blueprintPreviewSettings.showLabels = storedLabels;
        }
      } catch (e) {
        // ignore persistence load errors
      }

      const applyPreviewSettings = () => {
        if (opacitySlider) opacitySlider.value = blueprintPreviewSettings.opacity;
        if (opacityInput) opacityInput.value = blueprintPreviewSettings.opacity;
        if (labelsToggle) labelsToggle.checked = blueprintPreviewSettings.showLabels;
      };

      const updateBlueprintPreview = () => {
        if (!blueprintData) return;
        buildBlueprintFromData(blueprintData);
      };

      const bindOpacityInputs = () => {
        if (!opacitySlider || !opacityInput) return;
        const sync = (value) => {
          const clamped = clampNumber(Number.parseFloat(value), 0.1, 1);
          blueprintPreviewSettings.opacity = clamped;
          opacitySlider.value = clamped;
          opacityInput.value = clamped;
          try {
            setItem(PERSIST_KEYS.blueprintOpacity, clamped);
          } catch (e) {
            // ignore persistence errors
          }
          updateBlueprintPreview();
        };
        opacitySlider.addEventListener('input', (e) => sync(e.target.value));
        opacityInput.addEventListener('input', (e) => sync(e.target.value));
      };

      const updateJsonField = () => {
        if (!blueprintData) {
          setBlueprintStatus('Blueprint status: no data loaded.', false);
          return;
        }
        jsonField.value = JSON.stringify(blueprintData, null, 2);
      };

      const validateRaw = (raw, label) => {
        const validation = validateBlueprint(raw);
        if (!validation.ok) {
          setBlueprintStatus(`${label}: ${validation.errors[0]}`, false);
          return { ok: false, validation };
        }
        setBlueprintStatus(`${label}: OK`);
        return { ok: true, validation };
      };

      saveBtn.addEventListener('click', () => {
        updateJsonField();
        setBlueprintStatus('Blueprint status: JSON ready.');
      });

      copyBtn.addEventListener('click', () => {
        if (!blueprintData) {
          setBlueprintStatus('Blueprint status: nothing to copy.', false);
          return;
        }
        const json = JSON.stringify(blueprintData, null, 2);
        jsonField.value = json;
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(json).then(() => {
            setBlueprintStatus('Blueprint status: copied to clipboard.');
          }).catch(() => {
            setBlueprintStatus('Blueprint status: copy failed.', false);
          });
        }
      });

      validateBtn.addEventListener('click', () => {
        const raw = jsonField.value.trim();
        if (raw) {
          try {
            const parsed = JSON.parse(raw);
            validateRaw(parsed, 'Blueprint validation');
          } catch (e) {
            setBlueprintStatus('Blueprint validation: invalid JSON.', false);
          }
        } else if (blueprintData) {
          validateRaw(blueprintData, 'Blueprint validation');
        } else {
          setBlueprintStatus('Blueprint validation: no data.', false);
        }
      });

      if (overlayUploadBtn) {
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = 'image/*';
        fileInput.style.display = 'none';
        overlayUploadBtn.insertAdjacentElement('afterend', fileInput);

        overlayUploadBtn.addEventListener('click', () => {
          fileInput.click();
        });

        fileInput.addEventListener('change', async (event) => {
          const file = event.target.files?.[0];
          if (!file) return;
          try {
            const result = await setOverlayImageFromFile(file);
            if (!result) return;

            mapOverlayImgW = result.meta?.width || MAP_OVERLAY_IMG_W;
            mapOverlayImgH = result.meta?.height || MAP_OVERLAY_IMG_H;
            applyOverlayCalibKey();

            const overlayResult = await createOverlayLayer({
              renderer,
              textureUrl: result.dataUrl,
              imgW: mapOverlayImgW,
              imgH: mapOverlayImgH,
              worldW: MAP_OVERLAY_WORLD_W,
              worldH: MAP_OVERLAY_WORLD_H,
              y: Y.overlay,
              opacity: overlaySettings?.opacity ?? OVERLAY_DEFAULTS.opacity,
              visible: overlaySettings?.visible ?? true,
              renderOnTop: false,
              dimmerOpacity: overlaySettings?.dimmer ?? OVERLAY_DEFAULTS.dimmer,
              overlayGroup: mapOverlayGroup,
              syncBlueprintRoot: syncBlueprintRootToOverlay,
              updateLineResolution,
              blueprintGroups: { overlayBounds }
            });

            if (mapOverlayMesh) mapOverlayGroup.remove(mapOverlayMesh);
            if (overlayDimmer) mapOverlayGroup.remove(overlayDimmer);
            mapOverlayMesh = overlayResult.mapOverlayMesh;
            overlayDimmer = overlayResult.overlayDimmer;
            mapCoordMapper = overlayResult.mapCoordMapper;
            overlayLayer = overlayResult;
            updateOverlayVisibility();
            verifyOverlayMapping();
          } catch (err) {
            console.warn('Failed to load uploaded overlay:', err);
          } finally {
            fileInput.value = '';
          }
        });
      }

      loadBtn.addEventListener('click', () => {
        const raw = jsonField.value.trim();
        if (!raw) {
          setBlueprintStatus('Blueprint load: paste JSON first.', false);
          return;
        }
        try {
          const parsed = JSON.parse(raw);
          const result = validateRaw(parsed, 'Blueprint load');
          if (!result.ok) return;
          blueprintModel.loadFromJSON(parsed);
          blueprintData = blueprintModel.getData();
          buildBlueprintFromData(blueprintData);
          rebuildBlueprintCity();
          setBlueprintStatus('Blueprint status: loaded from textarea.');
        } catch (e) {
          setBlueprintStatus('Blueprint load: invalid JSON.', false);
        }
      });

      if (useCityToggle) {
        useCityToggle.checked = blueprintCityEnabled;
        useCityToggle.addEventListener('change', (e) => {
          setBlueprintCityEnabled(!!e.target.checked);
        });
      }

      if (labelsToggle) {
        labelsToggle.addEventListener('change', (e) => {
          blueprintPreviewSettings.showLabels = !!e.target.checked;
          try {
            setItem(PERSIST_KEYS.blueprintShowLabels, blueprintPreviewSettings.showLabels);
          } catch (e) {
            // ignore persistence errors
          }
          updateBlueprintPreview();
        });
      }

      bindOpacityInputs();
      applyPreviewSettings();
    }

    function editorActive() {
      return editorState.enabled && viewMode === 'fidelity';
    }

    function getEditorMode() {
      if (!editorActive()) return 'disabled';
      if (editorState.tool === 'polygon') return 'draw-polygon';
      if (editorState.tool === 'polyline') return 'draw-polyline';
      if (editorState.tool === 'poi') return 'poi';
      return editorState.selected ? 'edit' : 'select';
    }

    function ensureEditorGroups() {
      if (!mapOverlayGroup || editorGroup) return;
      editorGroup = new THREE.Group();
      editorGroup.name = 'EditorGroup';
      mapOverlayGroup.add(editorGroup);

      const draftMat = new LineMaterial({ color: 0xffff66, linewidth: 3, transparent: true, opacity: 0.95 });
      draftMat.depthTest = false;
      editorDraftLine = new Line2(new LineGeometry(), draftMat);
      editorDraftLine.renderOrder = 999;
      editorDraftLine.frustumCulled = false;
      editorDraftLine.position.y = Y.overlay + 0.07;
      editorGroup.add(editorDraftLine);

      const draftGlowMat = new LineMaterial({ color: 0xffffff, linewidth: 8, transparent: true, opacity: 0.35 });
      draftGlowMat.depthTest = false;
      editorDraftGlowLine = new Line2(new LineGeometry(), draftGlowMat);
      editorDraftGlowLine.renderOrder = 998;
      editorDraftGlowLine.frustumCulled = false;
      editorDraftGlowLine.position.y = Y.overlay + 0.071;
      editorGroup.add(editorDraftGlowLine);

      const selectMat = new LineMaterial({ color: 0xffee55, linewidth: 3, transparent: true, opacity: 0.95 });
      selectMat.depthTest = false;
      editorSelectionLine = new Line2(new LineGeometry(), selectMat);
      editorSelectionLine.renderOrder = 999;
      editorSelectionLine.frustumCulled = false;
      editorSelectionLine.position.y = Y.overlay + 0.08;
      editorGroup.add(editorSelectionLine);

      const selectGlowMat = new LineMaterial({ color: 0xffffff, linewidth: 8, transparent: true, opacity: 0.35 });
      selectGlowMat.depthTest = false;
      editorSelectionGlowLine = new Line2(new LineGeometry(), selectGlowMat);
      editorSelectionGlowLine.renderOrder = 998;
      editorSelectionGlowLine.frustumCulled = false;
      editorSelectionGlowLine.position.y = Y.overlay + 0.081;
      editorGroup.add(editorSelectionGlowLine);

      const ribbonDraftMat = new THREE.MeshBasicMaterial({
        color: 0x2b2b2b,
        transparent: true,
        opacity: 0.6,
        depthWrite: false,
        depthTest: true,
        side: THREE.DoubleSide,
        polygonOffset: true,
        polygonOffsetFactor: -1,
        polygonOffsetUnits: -1
      });
      editorDraftRibbon = new THREE.Mesh(new THREE.BufferGeometry(), ribbonDraftMat);
      editorDraftRibbon.renderOrder = 998;
      editorDraftRibbon.visible = false;
      editorGroup.add(editorDraftRibbon);

      const ribbonSelectMat = new THREE.MeshBasicMaterial({
        color: 0x2b2b2b,
        transparent: true,
        opacity: 0.75,
        depthWrite: false,
        depthTest: true,
        side: THREE.DoubleSide,
        polygonOffset: true,
        polygonOffsetFactor: -1,
        polygonOffsetUnits: -1
      });
      editorSelectionRibbon = new THREE.Mesh(new THREE.BufferGeometry(), ribbonSelectMat);
      editorSelectionRibbon.renderOrder = 997;
      editorSelectionRibbon.visible = false;
      editorGroup.add(editorSelectionRibbon);

      editorVertexGroup = new THREE.Group();
      editorVertexGroup.name = 'EditorVertices';
      editorGroup.add(editorVertexGroup);

      editorDraftVertexGroup = new THREE.Group();
      editorDraftVertexGroup.name = 'EditorDraftVertices';
      editorGroup.add(editorDraftVertexGroup);

      editorLineEndpointGroup = new THREE.Group();
      editorLineEndpointGroup.name = 'EditorLineEndpoints';
      editorGroup.add(editorLineEndpointGroup);

      editorJunctionMarkerGroup = new THREE.Group();
      editorJunctionMarkerGroup.name = 'EditorJunctionMarkers';
      editorGroup.add(editorJunctionMarkerGroup);
      editorGroup.visible = editorState.enabled;

      updateLineResolution(editorDraftLine);
      updateLineResolution(editorDraftGlowLine);
      updateLineResolution(editorSelectionLine);
      updateLineResolution(editorSelectionGlowLine);
    }

    function updateEditorStatus(text) {
      const el = document.getElementById('editorStatus');
      if (!el) return;
      el.textContent = text;
    }

    function updateLineResolution(line) {
      if (!line || !line.material || !line.material.resolution) return;
      line.material.resolution.set(window.innerWidth, window.innerHeight);
    }

    function canPanMap() {
      const viewW = (orthoCamera.right - orthoCamera.left) / orthoCamera.zoom;
      const viewH = (orthoCamera.top - orthoCamera.bottom) / orthoCamera.zoom;
      return (MAP_WIDTH > viewW + 1) || (MAP_HEIGHT > viewH + 1);
    }

    function applyPanDelta(dxPx, dyPx) {
      const viewW = (orthoCamera.right - orthoCamera.left) / orthoCamera.zoom;
      const viewH = (orthoCamera.top - orthoCamera.bottom) / orthoCamera.zoom;
      const worldPerPxX = viewW / window.innerWidth;
      const worldPerPxZ = viewH / window.innerHeight;
      const dxWorld = -dxPx * worldPerPxX;
      const dzWorld = -dyPx * worldPerPxZ;
      orthoCamera.position.x += dxWorld;
      orthoCamera.position.z += dzWorld;
      orthoCamera.lookAt(orthoCamera.position.x, 0, orthoCamera.position.z);
      orthoCamera.updateProjectionMatrix();
    }

    function applyEditorZoom(value) {
      const zoom = clampNumber(Number.parseFloat(value), 0.5, 3);
      editorState.mapZoom = zoom;
      orthoCamera.zoom = zoom;
      orthoCamera.updateProjectionMatrix();
    }

    function applyHandleScale(value) {
      const scale = clampNumber(Number.parseFloat(value), 0.4, 2.5);
      editorState.handleScale = scale;
      updateDraftMarkers();
      updateSelectionMarkers();
      updateLineEndpointMarkers();
    }

    function getEditorHitRadius(base) {
      const scale = editorState.handleScale || 1;
      const zoom = editorState.mapZoom || 1;
      return (base * scale) / zoom;
    }

    function hideEditorLines() {
      if (editorDraftLine) editorDraftLine.visible = false;
      if (editorDraftGlowLine) editorDraftGlowLine.visible = false;
      if (editorSelectionLine) editorSelectionLine.visible = false;
      if (editorSelectionGlowLine) editorSelectionGlowLine.visible = false;
      if (editorDraftRibbon) editorDraftRibbon.visible = false;
      if (editorSelectionRibbon) editorSelectionRibbon.visible = false;
    }

    function setLinePositions(line, points, closed = false) {
      if (!line) return;
      if (!points || points.length < 2) {
        line.visible = false;
        return;
      }
      const verts = [];
      points.forEach(p => {
        verts.push(p[0], 0, p[1]);
      });
      if (closed && points.length > 2) {
        const first = points[0];
        verts.push(first[0], 0, first[1]);
      }
      const nextGeometry = new LineGeometry();
      nextGeometry.setPositions(verts);
      if (line.geometry) line.geometry.dispose();
      line.geometry = nextGeometry;
      const instStart = line.geometry.attributes?.instanceStart;
      if (instStart) line.geometry.instanceCount = instStart.count;
      line.computeLineDistances();
      line.visible = true;
    }

    function updateRibbonMesh(mesh, points, width, y, color, opacity = 0.7) {
      if (!mesh) return;
      if (!points || points.length < 2) {
        mesh.visible = false;
        return;
      }
      const geometry = buildRibbonGeometryFromPolyline(points, width, y, {
        roundSegments: ROAD_JOIN_SETTINGS.roundSegments,
        minAngle: ROAD_JOIN_SETTINGS.minAngle,
        maxAngle: ROAD_JOIN_SETTINGS.maxAngle
      });
      if (!geometry) {
        mesh.visible = false;
        return;
      }
      if (mesh.geometry) mesh.geometry.dispose();
      mesh.geometry = geometry;
      if (mesh.material) {
        mesh.material.color.setHex(color);
        mesh.material.opacity = opacity;
      }
      mesh.visible = true;
    }

    function getRoadSurfaceY(lineType) {
      const style = getRoadLineStyle(lineType);
      const yOffset = style?.yOffset ?? 0;
      return Y.roads + yOffset;
    }

    function getEditorLineYForPolyline(lineType) {
      const normalized = normalizeLineType(lineType);
      if (isTransitLine(normalized)) return Y.roads + 0.6;
      return getRoadSurfaceY(normalized);
    }

    function setEditorLineHeights(yValue, { draft = false, selection = false } = {}) {
      const yMain = yValue;
      const yGlow = yValue + 0.001;
      if (draft) {
        if (editorDraftLine) editorDraftLine.position.y = yMain;
        if (editorDraftGlowLine) editorDraftGlowLine.position.y = yGlow;
      }
      if (selection) {
        if (editorSelectionLine) editorSelectionLine.position.y = yMain;
        if (editorSelectionGlowLine) editorSelectionGlowLine.position.y = yGlow;
      }
    }

    function updateEditorUIState() {
      const toolSelect = document.getElementById('editorTool');
      const layerSelect = document.getElementById('editorLayer');
      const typeSelect = document.getElementById('editorTypeCode');
      const poiSelect = document.getElementById('editorPoiType');
      const transitSelect = document.getElementById('editorTransitType');
      const junctionToggle = document.getElementById('editorJunctionMode');
      const junctionSplitToggle = document.getElementById('editorJunctionAutoSplit');
      const debugOffsetsToggle = document.getElementById('editorDebugRoadOffsets');
      const zoomSlider = document.getElementById('editorZoom');
      const zoomValue = document.getElementById('editorZoomValue');
      const scaleSlider = document.getElementById('editorHandleScale');
      const scaleValue = document.getElementById('editorHandleScaleValue');
      if (toolSelect) toolSelect.value = editorState.tool;
      if (layerSelect) {
        layerSelect.value = editorState.targetLayer;
        layerSelect.disabled = editorState.tool === 'polyline';
      }
      if (typeSelect) {
        typeSelect.disabled = editorState.tool === 'polyline' ||
          (editorState.targetLayer !== 'zones' && editorState.targetLayer !== 'buildings');
        typeSelect.value = editorState.typeCode;
      }
      if (poiSelect) {
        poiSelect.disabled = (editorState.tool !== 'poi');
        poiSelect.value = editorState.poiType;
      }
      if (transitSelect) {
        transitSelect.disabled = (editorState.tool !== 'polyline');
        transitSelect.value = editorState.transitType;
      }
      if (junctionToggle) junctionToggle.checked = editorState.junctionInsertMode;
      if (junctionSplitToggle) junctionSplitToggle.checked = editorState.junctionAutoSplit;
      if (debugOffsetsToggle) debugOffsetsToggle.checked = editorState.debugRoadOffsets;
      if (zoomSlider) zoomSlider.value = editorState.mapZoom;
      if (zoomValue) zoomValue.value = editorState.mapZoom;
      if (scaleSlider) scaleSlider.value = editorState.handleScale;
      if (scaleValue) scaleValue.value = editorState.handleScale;
      const trafficCarSlider = document.getElementById('trafficCarCount');
      const trafficCarValue = document.getElementById('trafficCarCountValue');
      const trafficSpeedSlider = document.getElementById('trafficSpeed');
      const trafficSpeedValue = document.getElementById('trafficSpeedValue');
      if (trafficCarSlider) trafficCarSlider.value = trafficRuntime.maxCars;
      if (trafficCarValue) trafficCarValue.value = trafficRuntime.maxCars;
      if (trafficSpeedSlider) trafficSpeedSlider.value = trafficRuntime.speedScale;
      if (trafficSpeedValue) trafficSpeedValue.value = trafficRuntime.speedScale;
      updateEditorHeightControls();
    }

    function updateEditorHeightControls() {
      const heightRange = document.getElementById('editorHeightRange');
      const heightValue = document.getElementById('editorHeightValue');
      const heightApply = document.getElementById('editorHeightApply');
      if (!heightRange || !heightValue || !heightApply) return;
      const selected = getSelectedEntry();
      const entry = selected?.entry || null;
      const isBuilding = selected?.layer === 'buildings';
      const info = entry ? getLegendInfo(entry.typeCode) : null;
      const enabled = !!(isBuilding && info?.buildable);
      heightRange.disabled = !enabled;
      heightValue.disabled = !enabled;
      heightApply.disabled = !enabled;
      if (!enabled) {
        heightRange.value = 0;
        heightValue.value = 0;
        return;
      }
      const height = Math.max(0, Math.min(2000, Math.round(getEntryHeight(entry))));
      heightRange.value = height;
      heightValue.value = height;
    }

    function getPointerMapPoint(event) {
      if (!mapOverlayGroup) return null;
      const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -Y.overlay);
      const mouseVec = new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
      );
      raycaster.setFromCamera(mouseVec, activeCamera);
      const hit = new THREE.Vector3();
      if (!raycaster.ray.intersectPlane(plane, hit)) return null;
      mapOverlayGroup.worldToLocal(hit);
      return { x: hit.x, z: hit.z };
    }

    function snapMapPoint(point) {
      let x = point.x;
      let z = point.z;

      if (editorState.snapGrid) {
        x = Math.round(x / GRID_STEP_X) * GRID_STEP_X;
        z = Math.round(z / GRID_STEP_Z) * GRID_STEP_Z;
      }

      if (editorState.snapPixels && mapCoordMapper) {
          const px = overlayLocalToPixel({ x, z }, mapCoordMapper);
        const step = Math.max(1, editorState.pixelStep);
        const snappedPx = {
          px: Math.round(px.px / step) * step,
          py: Math.round(px.py / step) * step
        };
        const snapped = pixelToOverlayLocal(snappedPx.px, snappedPx.py, mapCoordMapper);
        if (snapped) {
          x = snapped.x;
          z = snapped.z;
        }
      }

      return { x, z };
    }

    function updateDraftLine() {
      if (!editorDraftLine || !editorDraftGlowLine) return;
      const points = editorState.draft;
      const color = LEGEND_LINE_COLORS[editorState.typeCode] ?? 0xffff66;
      let lineColor = color;
      let useRibbonPreview = false;
      let ribbonStyle = null;
      if (editorState.tool === 'polyline') {
        const lineType = normalizeLineType(editorState.transitType);
        if (isTransitLine(lineType)) {
          const style = TRANSIT_STYLES[lineType] || TRANSIT_STYLES.METRO;
          lineColor = style.color;
        } else {
          ribbonStyle = getRoadLineStyle(lineType);
          lineColor = ribbonStyle.outline;
          useRibbonPreview = USE_RIBBON_ROADS;
        }
        setEditorLineHeights(getEditorLineYForPolyline(lineType), { draft: true });
      } else if (editorState.targetLayer === 'roads') {
        lineColor = 0xffffff;
        setEditorLineHeights(getRoadSurfaceY('ROAD_MAJOR'), { draft: true });
      } else if (editorState.targetLayer === 'coastlines') {
        lineColor = 0x00f0ff;
        setEditorLineHeights(Y.overlay + 0.07, { draft: true });
      } else if (editorState.targetLayer === 'beaches') {
        lineColor = 0xffd27a;
        setEditorLineHeights(Y.overlay + 0.07, { draft: true });
      } else if (editorState.targetLayer === 'sea') {
        lineColor = 0x3aa6ff;
        setEditorLineHeights(Y.overlay + 0.07, { draft: true });
      } else {
        setEditorLineHeights(Y.overlay + 0.07, { draft: true });
      }
      editorDraftLine.material.color.setHex(lineColor);

      if (!points || points.length === 0) {
        editorDraftLine.visible = false;
        editorDraftGlowLine.visible = false;
        if (editorDraftRibbon) editorDraftRibbon.visible = false;
        return;
      }

      if (points.length < 2 && !editorState.previewPoint) {
        editorDraftLine.visible = false;
        editorDraftGlowLine.visible = false;
        if (editorDraftRibbon) editorDraftRibbon.visible = false;
        return;
      }
      const renderPoints = points.slice();
      if (editorState.previewPoint && points.length >= 1) {
        renderPoints.push(editorState.previewPoint);
      }
      if (useRibbonPreview && ribbonStyle) {
        const width = ribbonStyle.width;
        updateRibbonMesh(editorDraftRibbon, renderPoints, width, getRoadSurfaceY(editorState.transitType), ribbonStyle.color, 0.55);
        editorDraftLine.visible = false;
        editorDraftGlowLine.visible = false;
      } else {
        if (editorDraftRibbon) editorDraftRibbon.visible = false;
        setLinePositions(editorDraftLine, renderPoints, false);
        editorDraftLine.visible = true;
        setLinePositions(editorDraftGlowLine, renderPoints, false);
        editorDraftGlowLine.visible = true;
      }
    }

    function updateDraftMarkers() {
      if (!editorDraftVertexGroup) return;
      resetGroup(editorDraftVertexGroup);
      const mode = getEditorMode();
      if (mode !== 'draw-polygon' && mode !== 'draw-polyline') return;
      const points = editorState.draft;
      if (!points || points.length === 0) return;

      const scale = editorState.handleScale || 1;
      const baseRadius = 5.2 * scale;
      const lastRadius = baseRadius * 1.3;
      const baseGeo = new THREE.SphereGeometry(baseRadius, 10, 10);
      const lastGeo = new THREE.SphereGeometry(lastRadius, 10, 10);
      const lastIndex = points.length - 1;

      points.forEach((pt, idx) => {
        const hovered = editorState.hoverDraftIndex === idx;
        const isLast = idx === lastIndex;
        const isJunctionBase = editorState.junctionMode && idx === 0;
        const color = hovered ? 0x000000 : (isJunctionBase ? 0xff8a00 : 0xffffff);
        const mat = new THREE.MeshBasicMaterial({
          color,
          transparent: true,
          opacity: hovered ? 0.95 : 0.9,
          depthTest: false,
          depthWrite: false
        });
        const sphere = new THREE.Mesh(isLast ? lastGeo : baseGeo, mat);
        sphere.position.set(pt[0], Y.overlay + 0.12, pt[1]);
        sphere.renderOrder = 1002;
        editorDraftVertexGroup.add(sphere);
      });
      updateLineEndpointMarkers();
    }

    function updateLineEndpointMarkers() {
      if (!editorLineEndpointGroup) return;
      resetGroup(editorLineEndpointGroup);
      if (!editorActive() || editorState.tool !== 'polyline' || !blueprintData) return;

      const scale = editorState.handleScale || 1;
      const sphereGeo = new THREE.SphereGeometry(6.2 * scale, 10, 10);
      const endpoints = [];
      const minDist2 = 36;

      const addEndpoint = (pt, meta) => {
        if (!pt) return;
        const existing = endpoints.find(item => {
          const dx = item.pt[0] - pt[0];
          const dz = item.pt[1] - pt[1];
          return (dx * dx + dz * dz) <= minDist2;
        });
        if (existing) {
          if (meta?.junction) existing.meta.junction = true;
          return;
        }
        endpoints.push({ pt, meta });
      };

      const gather = (entries, layer) => {
        entries.forEach((entry, idx) => {
          if (!entry?.polyline || entry.polyline.length < 2) return;
          addEndpoint(entry.polyline[0], { layer, index: idx, vertexIndex: 0 });
          addEndpoint(entry.polyline[entry.polyline.length - 1], { layer, index: idx, vertexIndex: entry.polyline.length - 1 });
          if (Array.isArray(entry.junctions)) {
            entry.junctions.forEach((junctionIndex) => {
              const pt = entry.polyline[junctionIndex];
              if (pt) addEndpoint(pt, { layer, index: idx, vertexIndex: junctionIndex, junction: true });
            });
          }
        });
      };

      gather(blueprintData.roads || [], 'roads');

      endpoints.forEach((item) => {
        const isHovered = editorState.hoverLineEndpoint &&
          editorState.hoverLineEndpoint.layer === item.meta.layer &&
          editorState.hoverLineEndpoint.index === item.meta.index &&
          editorState.hoverLineEndpoint.vertexIndex === item.meta.vertexIndex;
        const baseColor = item.meta?.junction ? 0xff8a00 : 0xffffff;
        const mat = new THREE.MeshBasicMaterial({
          color: isHovered ? 0x000000 : baseColor,
          transparent: true,
          opacity: isHovered ? 0.95 : 0.85,
          depthTest: false,
          depthWrite: false
        });
        const sphere = new THREE.Mesh(sphereGeo, mat);
        sphere.position.set(item.pt[0], Y.overlay + 0.12, item.pt[1]);
        sphere.renderOrder = 1003;
        editorLineEndpointGroup.add(sphere);
      });
    }

    function updateJunctionMarkers() {
      if (!editorJunctionMarkerGroup) return;
      resetGroup(editorJunctionMarkerGroup);
      if (!editorActive() || !editorState.junctionInsertMode) return;
      const hover = editorState.hoverJunction;
      if (!hover || !hover.point) return;
      const scale = editorState.handleScale || 1;
      const radius = 6.6 * scale;
      const mat = new THREE.MeshBasicMaterial({
        color: 0xff8a00,
        transparent: true,
        opacity: 0.95,
        depthTest: false,
        depthWrite: false
      });
      const geo = new THREE.SphereGeometry(radius, 10, 10);
      const marker = new THREE.Mesh(geo, mat);
      marker.position.set(hover.point.x, Y.overlay + 0.135, hover.point.z);
      marker.renderOrder = 1005;
      editorJunctionMarkerGroup.add(marker);
    }

    function scheduleEditorRebuild() {
      if (editorRebuildRaf) return;
      editorRebuildRaf = requestAnimationFrame(() => {
        editorRebuildRaf = null;
        if (!blueprintData) return;
        buildBlueprintFromData(blueprintData);
        rebuildBlueprintCity();
        updateSelectionMarkers();
      });
    }

    function updateSelectionMarkers() {
      if (!editorVertexGroup || !editorSelectionLine || !editorSelectionGlowLine) return;
      resetGroup(editorVertexGroup);
      editorSelectionLine.visible = false;
      editorSelectionGlowLine.visible = false;

      const selection = editorState.selected;
      if (!selection || !blueprintData) {
        updateEditorHeightControls();
        return;
      }
      const list = blueprintData[selection.layer];
      if (!list || !list[selection.index]) {
        updateEditorHeightControls();
        return;
      }
      const entry = list[selection.index];
      const renderLinePoints = entry.polyline ? getRenderPolylinePoints(entry) : getRenderPolygonPoints(entry);
      if (!renderLinePoints || renderLinePoints.length < 2) return;
      const isClosed = !entry.polyline;

      const selectionKind = getLineKind(entry);
      const useRibbonSelection = selection.layer === 'roads' && entry.polyline && USE_RIBBON_ROADS && !isTransitKind(selectionKind);
      if (!useRibbonSelection) {
        setLinePositions(editorSelectionLine, renderLinePoints, isClosed);
        setLinePositions(editorSelectionGlowLine, renderLinePoints, isClosed);
      }

      if (selection.layer === 'roads') {
        const kind = selectionKind;
        if (entry.polyline && isTransitKind(kind)) {
          const style = TRANSIT_STYLES[kind] || TRANSIT_STYLES.METRO;
          editorSelectionLine.material.color.setHex(style.color);
          setEditorLineHeights(getEditorLineYForPolyline(kind), { selection: true });
          editorSelectionLine.visible = true;
          editorSelectionGlowLine.visible = true;
          if (editorSelectionRibbon) editorSelectionRibbon.visible = false;
        } else if (useRibbonSelection) {
          const style = getRoadLineStyle(kind);
          const width = Number.isFinite(entry.width) ? entry.width : style.width;
          updateRibbonMesh(editorSelectionRibbon, renderLinePoints, width, getRoadSurfaceY(kind), style.color, 0.65);
          editorSelectionLine.visible = false;
          editorSelectionGlowLine.visible = false;
        } else {
          const style = getRoadLineStyle(kind);
          editorSelectionLine.material.color.setHex(style.outline);
          setEditorLineHeights(getRoadSurfaceY(kind), { selection: true });
          editorSelectionLine.visible = true;
          editorSelectionGlowLine.visible = true;
          if (editorSelectionRibbon) editorSelectionRibbon.visible = false;
        }
      } else if (selection.layer === 'coastlines') {
        editorSelectionLine.material.color.setHex(0x00f0ff);
        setEditorLineHeights(Y.overlay + 0.08, { selection: true });
        if (editorSelectionRibbon) editorSelectionRibbon.visible = false;
      } else if (selection.layer === 'beaches') {
        editorSelectionLine.material.color.setHex(0xffd27a);
        setEditorLineHeights(Y.overlay + 0.08, { selection: true });
        if (editorSelectionRibbon) editorSelectionRibbon.visible = false;
      } else if (selection.layer === 'sea') {
        editorSelectionLine.material.color.setHex(0x3aa6ff);
        setEditorLineHeights(Y.overlay + 0.08, { selection: true });
        if (editorSelectionRibbon) editorSelectionRibbon.visible = false;
      } else if (selection.layer === 'transit') {
        const type = String(entry.type || '').toUpperCase();
        const style = TRANSIT_STYLES[type] || TRANSIT_STYLES.METRO;
        editorSelectionLine.material.color.setHex(style.color);
        setEditorLineHeights(getEditorLineYForPolyline(type), { selection: true });
        if (editorSelectionRibbon) editorSelectionRibbon.visible = false;
      } else {
        const code = normalizeTypeCode(entry.typeCode);
        editorSelectionLine.material.color.setHex(LEGEND_LINE_COLORS[code] ?? 0xffff66);
        setEditorLineHeights(Y.overlay + 0.08, { selection: true });
        if (editorSelectionRibbon) editorSelectionRibbon.visible = false;
      }
      if (!useRibbonSelection) {
        editorSelectionLine.visible = true;
        editorSelectionGlowLine.visible = true;
      }

      const scale = editorState.handleScale || 1;
      const sphereGeo = new THREE.SphereGeometry(6.5 * scale, 10, 10);
      const vertexPoints = entry.polyline ? entry.polyline : entry.polygon;
      if (!vertexPoints) return;
      vertexPoints.forEach((pt, idx) => {
        const isActive = idx === selection.vertexIndex;
        const isHovered = editorState.hover &&
          editorState.hover.layer === selection.layer &&
          editorState.hover.index === selection.index &&
          editorState.hover.vertexIndex === idx;
        const isCurve = entry.polyline && Array.isArray(entry.curves) && entry.curves.includes(idx);
        const baseColor = isCurve ? 0x6f6f6f : 0xffffff;
        const mat = new THREE.MeshBasicMaterial({
          color: (isActive || isHovered) ? 0x000000 : baseColor,
          transparent: true,
          opacity: (isActive || isHovered) ? 0.95 : (isCurve ? 0.6 : 0.9),
          depthTest: false,
          depthWrite: false
        });
        const sphere = new THREE.Mesh(sphereGeo, mat);
        sphere.position.set(pt[0], Y.overlay + 0.12, pt[1]);
        sphere.renderOrder = 1002;
        editorVertexGroup.add(sphere);
      });
      updateEditorHeightControls();
      updateLineEndpointMarkers();
    }

    function findNearestVertex(point, threshold) {
      if (!blueprintData) return null;
      const layers = ['buildings', 'zones', 'roads', 'coastlines', 'beaches', 'sea'];
      let best = null;
      const thresh2 = threshold * threshold;

      layers.forEach(layer => {
        const list = blueprintData[layer] || [];
        list.forEach((entry, idx) => {
          const points = entry.polyline ? entry.polyline : entry.polygon;
          if (!points) return;
          points.forEach((pt, vIdx) => {
            const dx = pt[0] - point.x;
            const dz = pt[1] - point.z;
            const d2 = dx * dx + dz * dz;
            if (d2 < thresh2 && (!best || d2 < best.dist2)) {
              best = { layer, index: idx, vertexIndex: vIdx, dist2: d2 };
            }
          });
        });
      });
      return best;
    }

    function findNearestVertexInEntry(entry, point, threshold) {
      if (!entry) return null;
      const points = entry.polyline ? entry.polyline : entry.polygon;
      if (!points || points.length === 0) return null;
      const thresh2 = threshold * threshold;
      let best = null;
      points.forEach((pt, vIdx) => {
        const dx = pt[0] - point.x;
        const dz = pt[1] - point.z;
        const d2 = dx * dx + dz * dz;
        if (d2 < thresh2 && (!best || d2 < best.dist2)) {
          best = { vertexIndex: vIdx, dist2: d2 };
        }
      });
      return best;
    }

    function getSelectedEntry() {
      if (!editorState.selected || !blueprintData) return null;
      const { layer, index } = editorState.selected;
      const list = blueprintData[layer];
      if (!list || !list[index]) return null;
      return { entry: list[index], layer, index };
    }

    function cloneBlueprintData(data) {
      const fallback = normalizeBlueprintData({});
      if (!data) return fallback;
      try {
        return JSON.parse(JSON.stringify(data));
      } catch (e) {
        console.warn('Blueprint clone failed, resetting.', e);
        return fallback;
      }
    }

    function snapshotEditorState() {
      return {
        blueprint: cloneBlueprintData(blueprintData),
        selected: editorState.selected ? { ...editorState.selected } : null
      };
    }

    function pushEditorHistory(snapshot) {
      if (!snapshot) return;
      editorHistory.undo.push(snapshot);
      if (editorHistory.undo.length > editorHistory.limit) {
        editorHistory.undo.shift();
      }
      editorHistory.redo = [];
    }

    function applyEditorSnapshot(snapshot, label) {
      blueprintModel.applySnapshot(snapshot?.blueprint || {});
      blueprintData = blueprintModel.getData();
      editorState.draft = [];
      editorState.previewPoint = null;
      clearJunctionMode();
      editorState.hover = null;
      editorState.hoverDraftIndex = null;
      if (snapshot?.selected &&
        blueprintData?.[snapshot.selected.layer]?.[snapshot.selected.index]) {
        editorState.selected = { ...snapshot.selected };
      } else {
        editorState.selected = null;
      }
      buildBlueprintFromData(blueprintData);
      rebuildBlueprintCity();
      updateDraftLine();
      updateDraftMarkers();
      updateSelectionMarkers();
      updateEditorStatus(label || 'History applied.');
    }

    function undoEditor() {
      if (editorHistory.undo.length === 0) {
        updateEditorStatus('Undo: nothing to undo.');
        return;
      }
      const current = snapshotEditorState();
      const snapshot = editorHistory.undo.pop();
      editorHistory.redo.push(current);
      applyEditorSnapshot(snapshot, 'Undo.');
    }

    function redoEditor() {
      if (editorHistory.redo.length === 0) {
        updateEditorStatus('Redo: nothing to redo.');
        return;
      }
      const current = snapshotEditorState();
      const snapshot = editorHistory.redo.pop();
      editorHistory.undo.push(current);
      applyEditorSnapshot(snapshot, 'Redo.');
    }

    function findNearestDraftVertex(point, threshold) {
      if (!editorState.draft || editorState.draft.length === 0) return null;
      const thresh2 = threshold * threshold;
      let best = null;
      editorState.draft.forEach((pt, idx) => {
        const dx = pt[0] - point.x;
        const dz = pt[1] - point.z;
        const d2 = dx * dx + dz * dz;
        if (d2 < thresh2 && (best === null || d2 < best.dist2)) {
          best = { index: idx, dist2: d2 };
        }
      });
      return best;
    }

    function findNearestEdge(point, threshold) {
      if (!blueprintData) return null;
      const layers = ['buildings', 'zones', 'roads', 'coastlines', 'beaches', 'sea'];
      const thresh2 = threshold * threshold;
      let best = null;
      layers.forEach(layer => {
        const list = blueprintData[layer] || [];
        list.forEach((entry, idx) => {
          const points = entry.polyline ? entry.polyline : entry.polygon;
          if (!points || points.length < 2) return;
          const maxIndex = entry.polyline ? points.length - 1 : points.length;
          for (let i = 0; i < maxIndex; i++) {
            const a = points[i];
            const b = points[(i + 1) % points.length];
            const res = distancePointToSegment(point, a, b);
            if (res.dist2 < thresh2 && (!best || res.dist2 < best.dist2)) {
              best = { layer, index: idx, segmentIndex: i + 1, segmentStart: i, dist2: res.dist2, point: res.closest, t: res.tClamped };
            }
          }
        });
      });
      return best;
    }

    function findNearestEdgeInEntry(entry, point, threshold) {
      if (!entry) return null;
      const points = entry.polyline ? entry.polyline : entry.polygon;
      if (!points || points.length < 2) return null;
      const thresh2 = threshold * threshold;
      const maxIndex = entry.polyline ? points.length - 1 : points.length;
      let best = null;
      for (let i = 0; i < maxIndex; i++) {
        const a = points[i];
        const b = points[(i + 1) % points.length];
        const res = distancePointToSegment(point, a, b);
        if (res.dist2 < thresh2 && (!best || res.dist2 < best.dist2)) {
          best = { segmentIndex: i + 1, segmentStart: i, dist2: res.dist2, point: res.closest, t: res.tClamped };
        }
      }
      return best;
    }

    function findNearestLineEndpoint(point, threshold) {
      if (!blueprintData) return null;
      const thresh2 = threshold * threshold;
      let best = null;
      const checkPolyline = (entry, layer, index) => {
        if (!entry?.polyline || entry.polyline.length < 2) return;
        const endpoints = [0, entry.polyline.length - 1];
        endpoints.forEach((vIdx) => {
          const pt = entry.polyline[vIdx];
          const dx = pt[0] - point.x;
          const dz = pt[1] - point.z;
          const d2 = dx * dx + dz * dz;
          if (d2 < thresh2 && (!best || d2 < best.dist2)) {
            best = { layer, index, vertexIndex: vIdx, dist2: d2, point: [pt[0], pt[1]] };
          }
        });
      };
      (blueprintData.roads || []).forEach((entry, idx) => checkPolyline(entry, 'roads', idx));
      return best;
    }

    function findNearestLineVertex(point, threshold) {
      if (!blueprintData) return null;
      const thresh2 = threshold * threshold;
      let best = null;
      (blueprintData.roads || []).forEach((entry, idx) => {
        if (!entry?.polyline || entry.polyline.length < 2) return;
        entry.polyline.forEach((pt, vIdx) => {
          const dx = pt[0] - point.x;
          const dz = pt[1] - point.z;
          const d2 = dx * dx + dz * dz;
          if (d2 < thresh2 && (!best || d2 < best.dist2)) {
            best = { layer: 'roads', index: idx, vertexIndex: vIdx, dist2: d2, point: [pt[0], pt[1]] };
          }
        });
      });
      return best;
    }

    function findNearestLineEdge(point, threshold) {
      if (!blueprintData) return null;
      const thresh2 = threshold * threshold;
      let best = null;
      (blueprintData.roads || []).forEach((entry, idx) => {
        if (!entry?.polyline || entry.polyline.length < 2) return;
        const points = entry.polyline;
        for (let i = 0; i < points.length - 1; i++) {
          const a = points[i];
          const b = points[i + 1];
          const res = distancePointToSegment(point, a, b);
          if (res.dist2 < thresh2 && (!best || res.dist2 < best.dist2)) {
            const segmentIndex = i + 1;
            if (!isCurveSegment(entry, segmentIndex)) {
              best = {
                layer: 'roads',
                index: idx,
                segmentIndex,
                segmentStart: i,
                dist2: res.dist2,
                point: res.closest,
                t: res.tClamped
              };
            }
          }
        }
      });
      return best;
    }

    function isCurveSegment(entry, segmentIndex) {
      if (!entry || !Array.isArray(entry.curves) || entry.curves.length === 0) return false;
      const points = entry.polyline ? entry.polyline : entry.polygon;
      if (!points || points.length < 2) return false;
      if (entry.polyline) {
        const count = points.length;
        return entry.curves.some((curveIndex) => {
          if (!Number.isInteger(curveIndex)) return false;
          if (curveIndex <= 0 || curveIndex >= count - 1) return false;
          const prevSegment = curveIndex;
          const nextSegment = curveIndex + 1;
          return segmentIndex === prevSegment || segmentIndex === nextSegment;
        });
      }
      const count = points.length;
      return entry.curves.some((curveIndex) => {
        if (!Number.isInteger(curveIndex)) return false;
        const prevSegment = curveIndex === 0 ? count : curveIndex;
        const nextSegment = curveIndex + 1 > count ? 1 : curveIndex + 1;
        return segmentIndex === prevSegment || segmentIndex === nextSegment;
      });
    }

    function getRenderPolylinePoints(entry) {
      if (!entry?.polyline || entry.polyline.length < 2) return [];
      const curveSet = new Set(entry.curves || []);
      if (curveSet.size === 0) return entry.polyline;
      const points = entry.polyline;
      const count = points.length;
      const out = [];
      const segments = 8;

      for (let i = 0; i < count; i++) {
        const curr = points[i];
        if (!curveSet.has(i) || i === 0 || i === count - 1) {
          out.push(curr);
          continue;
        }
        const prev = points[i - 1];
        const next = points[i + 1];
        const curve = new THREE.QuadraticBezierCurve3(
          new THREE.Vector3(prev[0], 0, prev[1]),
          new THREE.Vector3(curr[0], 0, curr[1]),
          new THREE.Vector3(next[0], 0, next[1])
        );
        const samples = curve.getPoints(segments);
        samples.forEach((pt, idx) => {
          if (idx === 0 && out.length > 0) return;
          out.push([pt.x, pt.z]);
        });
      }
      return out;
    }

    function getRenderPolygonPoints(entry) {
      if (!entry?.polygon || entry.polygon.length < 2) return [];
      const curveSet = new Set(entry.curves || []);
      if (curveSet.size === 0) return entry.polygon;

      const points = entry.polygon;
      const count = points.length;
      const out = [];
      const segments = 8;

      for (let i = 0; i < count; i++) {
        const curr = points[i];
        if (!curveSet.has(i)) {
          out.push(curr);
          continue;
        }
        const prev = points[(i - 1 + count) % count];
        const next = points[(i + 1) % count];
        const curve = new THREE.QuadraticBezierCurve3(
          new THREE.Vector3(prev[0], 0, prev[1]),
          new THREE.Vector3(curr[0], 0, curr[1]),
          new THREE.Vector3(next[0], 0, next[1])
        );
        const samples = curve.getPoints(segments);
        samples.forEach((pt, idx) => {
          if (idx === 0 && out.length > 0) return;
          out.push([pt.x, pt.z]);
        });
      }
      return out;
    }

    function findPolygonHit(point) {
      if (!blueprintData) return null;
      const layers = ['buildings', 'zones', 'roads', 'coastlines', 'beaches', 'sea'];
      for (const layer of layers) {
        const list = blueprintData[layer] || [];
        for (let idx = 0; idx < list.length; idx++) {
          const entry = list[idx];
          if (!entry.polygon) continue;
          const poly = getRenderPolygonPoints(entry);
          if (pointInPolygon(point.x, point.z, poly)) {
            return { layer, index: idx, vertexIndex: null };
          }
        }
      }
      return null;
    }

    function selectAtPoint(point) {
      const vertexHit = findNearestVertex(point, getEditorHitRadius(12));
      if (vertexHit) return vertexHit;
      const edgeHit = findNearestEdge(point, getEditorHitRadius(10));
      if (edgeHit && edgeHit.layer === 'roads') {
        const entry = blueprintData?.roads?.[edgeHit.index];
        if (entry?.polyline) {
          return { layer: edgeHit.layer, index: edgeHit.index, vertexIndex: null };
        }
      }
      return findPolygonHit(point);
    }

    function updateEditorHover(point) {
      if (!editorActive()) return;
      editorState.hover = null;
      editorState.hoverDraftIndex = null;
      editorState.hoverLineEndpoint = null;
      editorState.hoverJunction = null;
      const mode = getEditorMode();
      if (mode === 'draw-polygon' || mode === 'draw-polyline') {
        const draftHit = findNearestDraftVertex(point, getEditorHitRadius(10));
        if (draftHit) {
          editorState.hoverDraftIndex = draftHit.index;
        }
        if (mode === 'draw-polyline') {
          const endpointHit = findNearestLineEndpoint(point, getEditorHitRadius(12));
          if (endpointHit) {
            editorState.hoverLineEndpoint = {
              layer: endpointHit.layer,
              index: endpointHit.index,
              vertexIndex: endpointHit.vertexIndex
            };
          }
          if (editorState.junctionInsertMode) {
            const edgeHit = findNearestLineEdge(point, getEditorHitRadius(14));
            if (edgeHit) {
              editorState.hoverJunction = edgeHit;
            }
          }
        }
      }
      if (mode === 'edit') {
        const selected = getSelectedEntry();
        if (selected) {
          const hit = findNearestVertexInEntry(selected.entry, point, getEditorHitRadius(10));
          if (hit) {
            editorState.hover = {
              layer: selected.layer,
              index: selected.index,
              vertexIndex: hit.vertexIndex
            };
          }
        }
        updateSelectionMarkers();
      }
      updateDraftMarkers();
      updateLineEndpointMarkers();
      updateJunctionMarkers();
    }

    function isDoubleClick(point) {
      const now = performance.now();
      const prev = editorState.lastPointerDown;
      editorState.lastPointerDown = { time: now, point: { x: point.x, z: point.z } };
      if (!prev) return false;
      const dt = now - prev.time;
      const dx = point.x - prev.point.x;
      const dz = point.z - prev.point.z;
      return dt < 320 && (dx * dx + dz * dz) < 36;
    }

    function addPolygonFromDraft() {
      if (!blueprintData) blueprintData = blueprintModel.createBlank();
      if (editorState.draft.length < 3) return;

      pushEditorHistory(snapshotEditorState());
      const id = `${editorState.targetLayer}-${Date.now()}`;
      const polygon = editorState.draft.map(p => [p[0], p[1]]);

      if (editorState.targetLayer === 'zones') {
        blueprintModel.addFeature('zones', { id, typeCode: editorState.typeCode, polygon, curves: [] });
      } else if (editorState.targetLayer === 'buildings') {
        blueprintModel.addFeature('buildings', { id, typeCode: editorState.typeCode, polygon, curves: [] });
      } else if (editorState.targetLayer === 'roads') {
        blueprintModel.addFeature('roads', { id, polygon, curves: [] });
      } else if (editorState.targetLayer === 'coastlines') {
        blueprintModel.addFeature('coastlines', { id, polygon, curves: [] });
      } else if (editorState.targetLayer === 'beaches') {
        blueprintModel.addFeature('beaches', { id, polygon, curves: [] });
      } else if (editorState.targetLayer === 'sea') {
        blueprintModel.addFeature('sea', { id, polygon, curves: [] });
      }

      editorState.draft = [];
      editorState.previewPoint = null;
      editorState.selected = { layer: editorState.targetLayer, index: (blueprintData[editorState.targetLayer].length - 1), vertexIndex: null };
      buildBlueprintFromData(blueprintData);
      rebuildBlueprintCity();
      updateDraftLine();
      updateDraftMarkers();
      updateSelectionMarkers();
      updateEditorStatus('Polygon added.');
    }

    function addPolylineFromDraft() {
      if (!blueprintData) blueprintData = blueprintModel.createBlank();
      if (editorState.draft.length < 2) return;
      pushEditorHistory(snapshotEditorState());
      const polyline = editorState.draft.map(p => [p[0], p[1]]);
      const lineType = normalizeLineType(editorState.transitType);
      const id = `line-${Date.now()}`;
      const style = getRoadLineStyle(lineType);
      const width = style?.width ?? (TRANSIT_STYLES[lineType]?.radius ? TRANSIT_STYLES[lineType].radius * 2 : 8);
      blueprintModel.addFeature('roads', {
        id,
        kind: lineType,
        type: lineType,
        polyline,
        width,
        curves: []
      });
      blueprintData.transit = [];
      editorState.draft = [];
      editorState.previewPoint = null;
      clearJunctionMode();
      editorState.selected = { layer: 'roads', index: (blueprintData.roads.length - 1), vertexIndex: null };
      buildBlueprintFromData(blueprintData);
      rebuildBlueprintCity();
      updateDraftLine();
      updateDraftMarkers();
      updateSelectionMarkers();
      if (isTransitKind(lineType)) {
        updateEditorStatus('Transit line added.');
      } else if (lineType === 'PATH') {
        updateEditorStatus('Path line added.');
      } else {
        updateEditorStatus('Road line added.');
      }
    }

    function deleteSelection() {
      if (!blueprintData || !editorState.selected) return;
      pushEditorHistory(snapshotEditorState());
      const { layer, index, vertexIndex } = editorState.selected;
      const list = blueprintData[layer];
      if (!list || !list[index]) return;
      const entry = list[index];
      const points = entry.polyline ? entry.polyline : entry.polygon;
      if (vertexIndex !== null && points) {
        points.splice(vertexIndex, 1);
        if (Array.isArray(entry.curves)) {
          entry.curves = entry.curves
            .filter(c => c !== vertexIndex)
            .map(c => (c > vertexIndex ? c - 1 : c));
        }
        const minLen = entry.polyline ? 2 : 3;
        if (points.length < minLen) {
          list.splice(index, 1);
          editorState.selected = null;
        } else {
          editorState.selected.vertexIndex = null;
        }
      } else {
        list.splice(index, 1);
        editorState.selected = null;
      }
      buildBlueprintFromData(blueprintData);
      rebuildBlueprintCity();
      updateSelectionMarkers();
      updateEditorStatus('Selection deleted.');
    }

    function addPoiAt(point) {
      if (!blueprintData) blueprintData = blueprintModel.createBlank();
      pushEditorHistory(snapshotEditorState());
      const id = `poi-${Date.now()}`;
      blueprintModel.addFeature('pois', { id, type: editorState.poiType, position: [point.x, point.z] });
      buildBlueprintFromData(blueprintData);
      rebuildBlueprintCity();
      updateEditorStatus('POI added.');
    }

    function setupEditorControls() {
      const enableToggle = document.getElementById('editorEnable');
      const undoBtn = document.getElementById('editorUndo');
      const redoBtn = document.getElementById('editorRedo');
      const toolSelect = document.getElementById('editorTool');
      const layerSelect = document.getElementById('editorLayer');
      const typeSelect = document.getElementById('editorTypeCode');
      const poiSelect = document.getElementById('editorPoiType');
      const transitSelect = document.getElementById('editorTransitType');
      const junctionToggle = document.getElementById('editorJunctionMode');
      const junctionSplitToggle = document.getElementById('editorJunctionAutoSplit');
      const debugOffsetsToggle = document.getElementById('editorDebugRoadOffsets');
      const trafficCarSlider = document.getElementById('trafficCarCount');
      const trafficCarValue = document.getElementById('trafficCarCountValue');
      const trafficSpeedSlider = document.getElementById('trafficSpeed');
      const trafficSpeedValue = document.getElementById('trafficSpeedValue');
      const heightRange = document.getElementById('editorHeightRange');
      const heightValue = document.getElementById('editorHeightValue');
      const heightApply = document.getElementById('editorHeightApply');
      const snapGridToggle = document.getElementById('editorSnapGrid');
      const snapPixelToggle = document.getElementById('editorSnapPixels');
      const pixelStepInput = document.getElementById('editorPixelStep');
      const zoomSlider = document.getElementById('editorZoom');
      const zoomValue = document.getElementById('editorZoomValue');
      const handleScaleSlider = document.getElementById('editorHandleScale');
      const handleScaleValue = document.getElementById('editorHandleScaleValue');
      const deleteBtn = document.getElementById('editorDelete');
      const clearBtn = document.getElementById('editorClear');
      const hideCityToggle = document.getElementById('editorHideCity');

      if (!enableToggle) return;

      try {
        const storedSnapGrid = getItem(PERSIST_KEYS.editorSnapGrid);
        if (typeof storedSnapGrid === 'boolean') editorState.snapGrid = storedSnapGrid;
        const storedSnapPixels = getItem(PERSIST_KEYS.editorSnapPixels);
        if (typeof storedSnapPixels === 'boolean') editorState.snapPixels = storedSnapPixels;
        const storedPixelStep = getItem(PERSIST_KEYS.editorPixelStep);
        if (Number.isFinite(storedPixelStep)) editorState.pixelStep = storedPixelStep;
        const storedMaxCars = getItem(PERSIST_KEYS.trafficMaxCars);
        if (Number.isFinite(storedMaxCars)) {
          trafficRuntime.maxCars = Math.max(0, Math.min(40, Number.parseInt(storedMaxCars, 10) || 0));
        }
        const storedSpeedScale = getItem(PERSIST_KEYS.trafficSpeedScale);
        if (Number.isFinite(storedSpeedScale)) {
          trafficRuntime.speedScale = Math.max(0.2, Math.min(3, Number.parseFloat(storedSpeedScale) || 1));
        }
      } catch (e) {
        // ignore persistence load errors
      }

      enableToggle.checked = editorState.enabled;
      enableToggle.addEventListener('change', (e) => {
        editorState.enabled = !!e.target.checked;
        ensureEditorGroups();
        if (editorGroup) editorGroup.visible = editorState.enabled && viewMode === 'fidelity';
        if (editorState.enabled && viewMode !== 'fidelity') {
          updateEditorStatus('Editor enabled (switch to Fidelity Mode).');
        } else {
          updateEditorStatus(editorState.enabled ? 'Editor enabled.' : 'Editor disabled.');
        }
        updateEditorUIState();
      });

      if (undoBtn) undoBtn.addEventListener('click', undoEditor);
      if (redoBtn) redoBtn.addEventListener('click', redoEditor);

      if (toolSelect) {
        toolSelect.addEventListener('change', (e) => {
          editorState.tool = e.target.value;
      if (editorState.tool === 'polygon' || editorState.tool === 'polyline') {
        editorState.selected = null;
        updateSelectionMarkers();
      }
      if (editorState.tool !== 'polygon' && editorState.tool !== 'polyline') {
        editorState.draft = [];
        editorState.previewPoint = null;
        updateDraftLine();
      }
      clearJunctionMode();
          updateEditorUIState();
          updateDraftMarkers();
          updateEditorStatus(`Tool: ${editorState.tool}`);
        });
      }

      if (layerSelect) {
        layerSelect.addEventListener('change', (e) => {
          editorState.targetLayer = e.target.value;
          if (editorState.targetLayer === 'transit') {
            editorState.tool = 'polyline';
          }
          updateEditorUIState();
          updateDraftLine();
          updateDraftMarkers();
        });
      }

      if (typeSelect) {
        typeSelect.addEventListener('change', (e) => {
          editorState.typeCode = e.target.value;
          updateDraftLine();
          updateSelectionMarkers();
        });
      }

      if (poiSelect) {
        poiSelect.addEventListener('change', (e) => {
          editorState.poiType = e.target.value;
        });
      }

      if (transitSelect) {
        transitSelect.addEventListener('change', (e) => {
          editorState.transitType = e.target.value;
          updateDraftLine();
          updateSelectionMarkers();
        });
      }

      if (junctionToggle) {
        junctionToggle.checked = editorState.junctionInsertMode;
        junctionToggle.addEventListener('change', (e) => {
          editorState.junctionInsertMode = !!e.target.checked;
          updateEditorStatus(editorState.junctionInsertMode ? 'Junction mode enabled.' : 'Junction mode disabled.');
        });
      }
      if (junctionSplitToggle) {
        junctionSplitToggle.checked = editorState.junctionAutoSplit;
        junctionSplitToggle.addEventListener('change', (e) => {
          editorState.junctionAutoSplit = !!e.target.checked;
        });
      }
      if (debugOffsetsToggle) {
        debugOffsetsToggle.checked = editorState.debugRoadOffsets;
        debugOffsetsToggle.addEventListener('change', (e) => {
          editorState.debugRoadOffsets = !!e.target.checked;
          buildBlueprintFromData(blueprintData || normalizeBlueprintData({}));
        });
      }

      const bindTrafficNumber = (slider, input, onChange) => {
        if (!slider || !input) return;
        const apply = (value) => {
          slider.value = value;
          input.value = value;
          onChange(value);
        };
        slider.addEventListener('input', (e) => apply(e.target.value));
        input.addEventListener('input', (e) => apply(e.target.value));
      };

      bindTrafficNumber(trafficCarSlider, trafficCarValue, (value) => {
        trafficRuntime.maxCars = Math.max(0, Math.min(40, Number.parseInt(value, 10) || 0));
        try {
          setItem(PERSIST_KEYS.trafficMaxCars, trafficRuntime.maxCars);
        } catch (e) {
          // ignore persistence errors
        }
        rebuildBlueprintTraffic();
      });

      bindTrafficNumber(trafficSpeedSlider, trafficSpeedValue, (value) => {
        trafficRuntime.speedScale = Math.max(0.2, Math.min(3, Number.parseFloat(value) || 1));
        try {
          setItem(PERSIST_KEYS.trafficSpeedScale, trafficRuntime.speedScale);
        } catch (e) {
          // ignore persistence errors
        }
      });

      if (heightRange && heightValue) {
        heightRange.addEventListener('input', (e) => {
          heightValue.value = e.target.value;
        });
        heightValue.addEventListener('input', (e) => {
          heightRange.value = e.target.value;
        });
      }

      if (heightApply) {
        heightApply.addEventListener('click', () => {
          const selected = getSelectedEntry();
          if (!selected || selected.layer !== 'buildings') return;
          const info = getLegendInfo(selected.entry.typeCode);
          if (!info.buildable) return;
          const height = Math.max(0, Math.min(2000, Number.parseFloat(heightValue?.value)));
          if (!Number.isFinite(height)) return;
          pushEditorHistory(snapshotEditorState());
          selected.entry.height = height;
          selected.entry.heightMeters = height;
          buildBlueprintFromData(blueprintData);
          rebuildBlueprintCity();
          updateSelectionMarkers();
          updateEditorStatus(`Height set to ${Math.round(height)}m.`);
        });
      }

      if (snapGridToggle) {
        snapGridToggle.addEventListener('change', (e) => {
          editorState.snapGrid = !!e.target.checked;
          try {
            setItem(PERSIST_KEYS.editorSnapGrid, editorState.snapGrid);
          } catch (e) {
            // ignore persistence errors
          }
        });
      }

      if (snapPixelToggle) {
        snapPixelToggle.addEventListener('change', (e) => {
          editorState.snapPixels = !!e.target.checked;
          try {
            setItem(PERSIST_KEYS.editorSnapPixels, editorState.snapPixels);
          } catch (e) {
            // ignore persistence errors
          }
        });
      }

      if (pixelStepInput) {
        pixelStepInput.addEventListener('input', (e) => {
          editorState.pixelStep = Number.parseFloat(e.target.value) || 1;
          try {
            setItem(PERSIST_KEYS.editorPixelStep, editorState.pixelStep);
          } catch (e) {
            // ignore persistence errors
          }
        });
      }

      const bindLinkedNumber = (slider, input, onChange) => {
        if (!slider || !input) return;
        const apply = (value) => {
          slider.value = value;
          input.value = value;
          onChange(value);
        };
        slider.addEventListener('input', (e) => apply(e.target.value));
        input.addEventListener('input', (e) => apply(e.target.value));
      };

      bindLinkedNumber(zoomSlider, zoomValue, (value) => applyEditorZoom(value));
      bindLinkedNumber(handleScaleSlider, handleScaleValue, (value) => applyHandleScale(value));

      if (deleteBtn) deleteBtn.addEventListener('click', deleteSelection);

      if (clearBtn) {
        clearBtn.addEventListener('click', () => {
          pushEditorHistory(snapshotEditorState());
          blueprintData = blueprintModel.createBlank();
          editorState.draft = [];
          editorState.previewPoint = null;
          clearJunctionMode();
          editorState.selected = null;
          editorState.hover = null;
          editorState.hoverDraftIndex = null;
          buildBlueprintFromData(blueprintData);
          rebuildBlueprintCity();
          updateDraftLine();
          updateDraftMarkers();
          updateSelectionMarkers();
          hideEditorLines();
          updateEditorStatus('Cleared all blueprint shapes.');
          setBlueprintStatus('Blueprint status: cleared in memory.');
        });
      }

      if (hideCityToggle) {
        hideCityToggle.checked = editorState.hideCity;
        hideCityToggle.addEventListener('change', (e) => {
          editorState.hideCity = !!e.target.checked;
          setCityLayerVisibility();
        });
      }

      updateDraftMarkers();
      updateEditorUIState();
      applyEditorZoom(editorState.mapZoom);
      applyHandleScale(editorState.handleScale);
    }

    function clearJunctionMode() {
      editorState.junctionMode = false;
      editorState.junctionBase = null;
    }

    function markJunctionIndex(entry, insertIndex) {
      if (!entry || !Number.isFinite(insertIndex)) return;
      if (!Array.isArray(entry.junctions)) entry.junctions = [];
      entry.junctions = entry.junctions.map(idx => (idx >= insertIndex ? idx + 1 : idx));
      if (!entry.junctions.includes(insertIndex)) {
        entry.junctions.push(insertIndex);
      }
    }

    function insertJunctionAtEdge(edgeHit) {
      if (!edgeHit || !blueprintData) return null;
      const entry = blueprintData?.[edgeHit.layer]?.[edgeHit.index];
      if (!entry?.polyline || entry.polyline.length < 2) return null;
      if (isCurveSegment(entry, edgeHit.segmentIndex)) return null;
      const insertIndex = edgeHit.segmentIndex;
      const points = entry.polyline;
      const start = points[insertIndex - 1];
      const end = points[insertIndex];
      if (!start || !end) return null;
      const t = Number.isFinite(edgeHit.t) ? edgeHit.t : 0.5;
      if (t <= 0.02) return { point: { x: start[0], z: start[1] }, inserted: false };
      if (t >= 0.98) return { point: { x: end[0], z: end[1] }, inserted: false };
      const newPoint = [edgeHit.point.x, edgeHit.point.z];
      points.splice(insertIndex, 0, newPoint);
      if (Array.isArray(entry.curves)) {
        entry.curves = entry.curves.map(c => (c >= insertIndex ? c + 1 : c));
      }
      markJunctionIndex(entry, insertIndex);
      return { point: { x: newPoint[0], z: newPoint[1] }, inserted: true };
    }

    function autoSplitRoadCrossings(point, sourceIndex) {
      if (!point || !blueprintData) return;
      const px = point.x;
      const pz = point.z;
      const radius = Math.max(2.5, getEditorHitRadius(10));
      const thresh2 = radius * radius;
      const roads = blueprintData.roads || [];
      roads.forEach((entry, idx) => {
        if (!entry?.polyline || entry.polyline.length < 2) return;
        if (idx === sourceIndex) return;
        const points = entry.polyline;
        for (let i = 0; i < points.length - 1; i++) {
          const a = points[i];
          const b = points[i + 1];
          const res = distancePointToSegment({ x: px, z: pz }, a, b);
          if (res.dist2 > thresh2) continue;
          if (res.tClamped <= 0.05 || res.tClamped >= 0.95) continue;
          const exists = points.some(pt => {
            const dx = pt[0] - px;
            const dz = pt[1] - pz;
            return (dx * dx + dz * dz) < 1;
          });
          if (exists) return;
          points.splice(i + 1, 0, [px, pz]);
          if (Array.isArray(entry.curves)) {
            entry.curves = entry.curves.map(c => (c >= i + 1 ? c + 1 : c));
          }
          markJunctionIndex(entry, i + 1);
          i += 1;
        }
      });
    }

    function handleEditorPointerDown(snapped, mapPoint, mode, doubleClickOverride = null) {
      const doubleClick = (typeof doubleClickOverride === 'boolean')
        ? doubleClickOverride
        : isDoubleClick(snapped);

      if (editorState.junctionInsertMode && editorState.tool === 'polyline') {
        const edgeHit = findNearestLineEdge(mapPoint, getEditorHitRadius(14));
        if (!edgeHit) {
          updateEditorStatus('Junction mode: tap a road edge.');
          return;
        }
        pushEditorHistory(snapshotEditorState());
        const result = insertJunctionAtEdge(edgeHit);
        if (result && result.inserted && editorState.junctionAutoSplit) {
          autoSplitRoadCrossings(result.point, edgeHit.index);
        }
        buildBlueprintFromData(blueprintData);
        rebuildBlueprintCity();
        updateSelectionMarkers();
        updateEditorStatus(result?.inserted ? 'Junction inserted.' : 'Junction snapped to endpoint.');
        return;
      }

      if (mode === 'draw-polygon' || mode === 'draw-polyline') {
        if (mode === 'draw-polyline' && editorState.draft.length >= 2) {
          const draftStart = editorState.draft[0];
          const dxStart = draftStart ? (mapPoint.x - draftStart[0]) : 0;
          const dzStart = draftStart ? (mapPoint.z - draftStart[1]) : 0;
          const closeStart = draftStart && (dxStart * dxStart + dzStart * dzStart) <= getEditorHitRadius(14) * getEditorHitRadius(14);
          if (closeStart) {
            const last = editorState.draft[editorState.draft.length - 1];
            if (!last || last[0] !== draftStart[0] || last[1] !== draftStart[1]) {
              editorState.draft.push([draftStart[0], draftStart[1]]);
            }
            addPolylineFromDraft();
            return;
          }
        }

        const draftHit = findNearestDraftVertex(snapped, getEditorHitRadius(10));
        if (draftHit) {
          editorState.dragging = { mode: 'draft', index: draftHit.index };
          return;
        }

        if (mode === 'draw-polyline') {
          const baseEndpointRadius = doubleClick ? 22 : 16;
          const baseEdgeRadius = doubleClick ? 24 : 12;
          const vertexHit = findNearestLineVertex(mapPoint, getEditorHitRadius(baseEndpointRadius));
          const endpointHit = findNearestLineEndpoint(mapPoint, getEditorHitRadius(baseEndpointRadius));
          const edgeHit = findNearestLineEdge(mapPoint, getEditorHitRadius(baseEdgeRadius));
          const edgeEntry = edgeHit ? blueprintData?.[edgeHit.layer]?.[edgeHit.index] : null;
          const edgeBlocked = edgeEntry ? isCurveSegment(edgeEntry, edgeHit.segmentIndex) : false;
          const usableEdgeHit = edgeHit && edgeEntry?.polyline && !edgeBlocked;

          if (doubleClick && (endpointHit || usableEdgeHit) && editorState.draft.length <= 1) {
            editorState.draft = [];
            if (usableEdgeHit) {
              pushEditorHistory(snapshotEditorState());
              if (Array.isArray(edgeEntry.curves)) {
                edgeEntry.curves = edgeEntry.curves.map(c => (c >= edgeHit.segmentIndex ? c + 1 : c));
              }
              edgeEntry.polyline.splice(edgeHit.segmentIndex, 0, [edgeHit.point.x, edgeHit.point.z]);
              editorState.selected = { layer: edgeHit.layer, index: edgeHit.index, vertexIndex: edgeHit.segmentIndex };
              editorState.draft = [[edgeHit.point.x, edgeHit.point.z]];
              editorState.junctionMode = true;
              editorState.junctionBase = [edgeHit.point.x, edgeHit.point.z];
              buildBlueprintFromData(blueprintData);
              rebuildBlueprintCity();
              updateDraftLine();
              updateDraftMarkers();
              updateSelectionMarkers();
              updateEditorStatus('Junction mode: continue drawing.');
              return;
            }
            if (endpointHit) {
              editorState.draft.push([endpointHit.point[0], endpointHit.point[1]]);
              editorState.junctionMode = true;
              editorState.junctionBase = [endpointHit.point[0], endpointHit.point[1]];
              updateDraftLine();
              updateDraftMarkers();
              updateEditorStatus(`Draft points: ${editorState.draft.length}`);
              return;
            }
          }

          if (editorState.draft.length === 0) {
            if (doubleClick && (endpointHit || usableEdgeHit)) {
              if (usableEdgeHit) {
                pushEditorHistory(snapshotEditorState());
                if (Array.isArray(edgeEntry.curves)) {
                  edgeEntry.curves = edgeEntry.curves.map(c => (c >= edgeHit.segmentIndex ? c + 1 : c));
                }
                edgeEntry.polyline.splice(edgeHit.segmentIndex, 0, [edgeHit.point.x, edgeHit.point.z]);
                editorState.selected = { layer: edgeHit.layer, index: edgeHit.index, vertexIndex: edgeHit.segmentIndex };
                editorState.draft = [[edgeHit.point.x, edgeHit.point.z]];
                editorState.junctionMode = true;
                editorState.junctionBase = [edgeHit.point.x, edgeHit.point.z];
                buildBlueprintFromData(blueprintData);
                rebuildBlueprintCity();
                updateDraftLine();
                updateDraftMarkers();
                updateSelectionMarkers();
                updateEditorStatus('Junction mode: continue drawing.');
                return;
              }
              if (endpointHit) {
                editorState.draft.push([endpointHit.point[0], endpointHit.point[1]]);
                editorState.junctionMode = true;
                editorState.junctionBase = [endpointHit.point[0], endpointHit.point[1]];
                updateDraftLine();
                updateDraftMarkers();
                updateEditorStatus(`Draft points: ${editorState.draft.length}`);
                return;
              }
            }

            if (vertexHit) {
              editorState.draft.push([vertexHit.point[0], vertexHit.point[1]]);
            } else if (endpointHit) {
              editorState.draft.push([endpointHit.point[0], endpointHit.point[1]]);
            } else {
              editorState.draft.push([snapped.x, snapped.z]);
            }
            clearJunctionMode();
            updateDraftLine();
            updateDraftMarkers();
            updateEditorStatus(`Draft points: ${editorState.draft.length}`);
            return;
          }

          const draftStart = editorState.draft[0];
          const dxStart = draftStart ? (mapPoint.x - draftStart[0]) : 0;
          const dzStart = draftStart ? (mapPoint.z - draftStart[1]) : 0;
          const closeStart = draftStart && (dxStart * dxStart + dzStart * dzStart) <= getEditorHitRadius(14) * getEditorHitRadius(14);
          if (closeStart && editorState.draft.length >= 2) {
            const last = editorState.draft[editorState.draft.length - 1];
            if (!last || last[0] !== draftStart[0] || last[1] !== draftStart[1]) {
              editorState.draft.push([draftStart[0], draftStart[1]]);
            }
            addPolylineFromDraft();
            return;
          }

          if (doubleClick) {
            if (endpointHit) {
              const last = editorState.draft[editorState.draft.length - 1];
              const dx = endpointHit.point[0] - last[0];
              const dz = endpointHit.point[1] - last[1];
              if (dx * dx + dz * dz > 0.0001) {
                editorState.draft.push([endpointHit.point[0], endpointHit.point[1]]);
              }
              addPolylineFromDraft();
              return;
            }
            if (vertexHit) {
              const last = editorState.draft[editorState.draft.length - 1];
              const dx = vertexHit.point[0] - last[0];
              const dz = vertexHit.point[1] - last[1];
              if (dx * dx + dz * dz > 0.0001) {
                editorState.draft.push([vertexHit.point[0], vertexHit.point[1]]);
              }
              addPolylineFromDraft();
              return;
            }
            if (usableEdgeHit) {
              pushEditorHistory(snapshotEditorState());
              if (Array.isArray(edgeEntry.curves)) {
                edgeEntry.curves = edgeEntry.curves.map(c => (c >= edgeHit.segmentIndex ? c + 1 : c));
              }
              edgeEntry.polyline.splice(edgeHit.segmentIndex, 0, [edgeHit.point.x, edgeHit.point.z]);
              editorState.draft.push([edgeHit.point.x, edgeHit.point.z]);
              addPolylineFromDraft();
              return;
            }
            editorState.draft.push([snapped.x, snapped.z]);
            addPolylineFromDraft();
            return;
          }

          if (vertexHit) {
            const last = editorState.draft[editorState.draft.length - 1];
            const dx = vertexHit.point[0] - last[0];
            const dz = vertexHit.point[1] - last[1];
            if (dx * dx + dz * dz > 0.0001) {
              editorState.draft.push([vertexHit.point[0], vertexHit.point[1]]);
            }
            addPolylineFromDraft();
            return;
          }

          if (endpointHit) {
            const last = editorState.draft[editorState.draft.length - 1];
            const dx = endpointHit.point[0] - last[0];
            const dz = endpointHit.point[1] - last[1];
            if (dx * dx + dz * dz > 0.0001) {
              editorState.draft.push([endpointHit.point[0], endpointHit.point[1]]);
            }
            addPolylineFromDraft();
            return;
          }

          if (usableEdgeHit) {
            pushEditorHistory(snapshotEditorState());
            if (Array.isArray(edgeEntry.curves)) {
              edgeEntry.curves = edgeEntry.curves.map(c => (c >= edgeHit.segmentIndex ? c + 1 : c));
            }
            edgeEntry.polyline.splice(edgeHit.segmentIndex, 0, [edgeHit.point.x, edgeHit.point.z]);
            editorState.draft.push([edgeHit.point.x, edgeHit.point.z]);
            addPolylineFromDraft();
            return;
          }
        }

        editorState.draft.push([snapped.x, snapped.z]);
        clearJunctionMode();
        updateDraftLine();
        updateDraftMarkers();
        updateEditorStatus(`Draft points: ${editorState.draft.length}`);
        return;
      }

      if (mode === 'poi') {
        addPoiAt(snapped);
        return;
      }

      if (mode === 'edit') {
        const selected = getSelectedEntry();
        if (selected) {
            const vertexHit = findNearestVertexInEntry(selected.entry, snapped, getEditorHitRadius(10));
          if (vertexHit) {
            if (selected.entry.polyline && doubleClick) {
              const points = selected.entry.polyline;
              const idx = vertexHit.vertexIndex;
              if (idx > 0 && idx < points.length - 1) {
                pushEditorHistory(snapshotEditorState());
                if (!Array.isArray(selected.entry.curves)) selected.entry.curves = [];
                const existing = selected.entry.curves.indexOf(idx);
                if (existing >= 0) {
                  selected.entry.curves.splice(existing, 1);
                  updateEditorStatus('Curve removed.');
                } else {
                  selected.entry.curves.push(idx);
                  updateEditorStatus('Curve added.');
                }
                buildBlueprintFromData(blueprintData);
                rebuildBlueprintCity();
                updateSelectionMarkers();
              }
              return;
            }

            const historySnapshot = snapshotEditorState();
            editorState.selected = {
              layer: selected.layer,
              index: selected.index,
              vertexIndex: vertexHit.vertexIndex
            };
            updateSelectionMarkers();
            editorState.dragging = {
              mode: 'vertex',
              start: { x: snapped.x, z: snapped.z },
              original: null,
              historySnapshot,
              historyPushed: false,
              didMove: false
            };
            return;
          }

          const edgeHit = findNearestEdgeInEntry(selected.entry, snapped, getEditorHitRadius(12));
          if (edgeHit) {
            const points = selected.entry.polyline ? selected.entry.polyline : selected.entry.polygon;
            if (points) {
              if (isCurveSegment(selected.entry, edgeHit.segmentIndex)) {
                updateEditorStatus('Curve segment locked. Use the curve handle.');
                return;
              }
              pushEditorHistory(snapshotEditorState());
              if (selected.entry.polygon) {
                if (!Array.isArray(selected.entry.curves)) selected.entry.curves = [];
                selected.entry.curves = selected.entry.curves.map(c => (c >= edgeHit.segmentIndex ? c + 1 : c));
                selected.entry.curves.push(edgeHit.segmentIndex);
              } else if (selected.entry.polyline && Array.isArray(selected.entry.curves)) {
                selected.entry.curves = selected.entry.curves.map(c => (c >= edgeHit.segmentIndex ? c + 1 : c));
              }
              points.splice(edgeHit.segmentIndex, 0, [edgeHit.point.x, edgeHit.point.z]);
              editorState.selected = { layer: selected.layer, index: selected.index, vertexIndex: edgeHit.segmentIndex };
              buildBlueprintFromData(blueprintData);
              rebuildBlueprintCity();
              updateSelectionMarkers();
              editorState.dragging = { mode: 'vertex', start: { x: snapped.x, z: snapped.z }, original: null };
            }
            return;
          }

          if (selected.entry.polygon && pointInPolygon(snapped.x, snapped.z, selected.entry.polygon)) {
            const historySnapshot = snapshotEditorState();
            editorState.dragging = {
              mode: 'polygon',
              start: { x: snapped.x, z: snapped.z },
              original: selected.entry.polygon.map(p => [p[0], p[1]]),
              curves: Array.isArray(selected.entry.curves) ? [...selected.entry.curves] : [],
              isPolyline: false,
              historySnapshot,
              historyPushed: false,
              didMove: false
            };
            return;
          }

          editorState.selected = null;
          updateSelectionMarkers();
          return;
        }
      }

      const selection = selectAtPoint(snapped);
      editorState.selected = selection;
      updateSelectionMarkers();

      if (selection && selection.vertexIndex !== null) {
        const historySnapshot = snapshotEditorState();
        editorState.dragging = {
          mode: 'vertex',
          start: { x: snapped.x, z: snapped.z },
          original: null,
          historySnapshot,
          historyPushed: false,
          didMove: false
        };
      } else if (selection) {
        const list = blueprintData?.[selection.layer];
        const entry = list?.[selection.index];
        if (entry?.polygon || entry?.polyline) {
          const historySnapshot = snapshotEditorState();
          editorState.dragging = {
            mode: 'polygon',
            start: { x: snapped.x, z: snapped.z },
            original: (entry.polyline || entry.polygon).map(p => [p[0], p[1]]),
            curves: Array.isArray(entry.curves) ? [...entry.curves] : [],
            isPolyline: !!entry.polyline,
            historySnapshot,
            historyPushed: false,
            didMove: false
          };
        }
      } else {
        editorState.selected = null;
      }
    }

    function bindEditorEvents() {
      renderer.domElement.style.touchAction = 'none';
      renderer.domElement.addEventListener('pointerdown', (e) => {
        if (!editorActive()) return;
        if (e.button !== 0) return;

        if (activeCamera === orthoCamera && e.pointerType === 'touch') {
          panState.touchPoints.set(e.pointerId, { x: e.clientX, y: e.clientY });
          if (panState.touchPoints.size >= 2 && canPanMap()) {
            panState.active = true;
            panState.isTouch = true;
            panState.pending = false;
            const pts = Array.from(panState.touchPoints.values());
            panState.lastX = (pts[0].x + pts[1].x) / 2;
            panState.lastY = (pts[0].y + pts[1].y) / 2;
            renderer.domElement.setPointerCapture(e.pointerId);
            return;
          }
        }

        const mapPoint = getPointerMapPoint(e);
        if (!mapPoint) return;
        const snapped = snapMapPoint(mapPoint);
        const mode = getEditorMode();
        const doubleClick = isDoubleClick(snapped);

        const canMousePan = (activeCamera === orthoCamera && canPanMap() && e.pointerType === 'mouse');
        let immediateDrag = false;
        if (mode === 'draw-polygon' || mode === 'draw-polyline') {
          immediateDrag = !!findNearestDraftVertex(snapped, 10);
        } else if (mode === 'edit') {
          const selected = getSelectedEntry();
          if (selected) {
            immediateDrag = !!findNearestVertexInEntry(selected.entry, snapped, 10);
            if (!immediateDrag) immediateDrag = !!findNearestEdgeInEntry(selected.entry, snapped, 12);
            if (!immediateDrag && selected.entry.polygon) {
              immediateDrag = pointInPolygon(snapped.x, snapped.z, selected.entry.polygon);
            }
          }
        } else if (mode === 'select') {
          immediateDrag = !!findNearestVertex(snapped, 12);
        }

        if (canMousePan && !immediateDrag) {
          panState.pending = true;
          panState.active = false;
          panState.isTouch = false;
          panState.pointerId = e.pointerId;
          panState.lastX = e.clientX;
          panState.lastY = e.clientY;
          panState.deferredAction = { snapped, mapPoint, mode, doubleClick };
          renderer.domElement.setPointerCapture(e.pointerId);
          return;
        }

        handleEditorPointerDown(snapped, mapPoint, mode, doubleClick);
      });

      renderer.domElement.addEventListener('pointermove', (e) => {
        if (!editorActive()) return;

        if (activeCamera === orthoCamera && e.pointerType === 'touch') {
          if (panState.touchPoints.has(e.pointerId)) {
            panState.touchPoints.set(e.pointerId, { x: e.clientX, y: e.clientY });
          }
          if (panState.active && panState.isTouch && panState.touchPoints.size >= 2) {
            const pts = Array.from(panState.touchPoints.values());
            const cx = (pts[0].x + pts[1].x) / 2;
            const cy = (pts[0].y + pts[1].y) / 2;
            const dx = cx - panState.lastX;
            const dy = cy - panState.lastY;
            panState.lastX = cx;
            panState.lastY = cy;
            applyPanDelta(dx, dy);
            return;
          }
        }

        if (panState.pending && e.pointerType === 'mouse' && e.pointerId === panState.pointerId) {
          const dx = e.clientX - panState.lastX;
          const dy = e.clientY - panState.lastY;
          if (Math.hypot(dx, dy) > 3) {
            panState.active = true;
            panState.pending = false;
          }
        }
        if (panState.active && !panState.isTouch && e.pointerId === panState.pointerId) {
          const dx = e.clientX - panState.lastX;
          const dy = e.clientY - panState.lastY;
          panState.lastX = e.clientX;
          panState.lastY = e.clientY;
          applyPanDelta(dx, dy);
          return;
        }

        const mapPoint = getPointerMapPoint(e);
        if (!mapPoint) return;
        const snapped = snapMapPoint(mapPoint);
        const mode = getEditorMode();

        if (!editorState.dragging) {
        if (mode === 'draw-polygon' || mode === 'draw-polyline') {
          if (editorState.draft.length > 0) {
            if (mode === 'draw-polyline') {
                const endpointHit = findNearestLineEndpoint(mapPoint, getEditorHitRadius(16));
                const vertexHit = findNearestLineVertex(mapPoint, getEditorHitRadius(16));
                const edgeHit = findNearestLineEdge(mapPoint, getEditorHitRadius(12));
                const draftStart = editorState.draft[0];
                const dxStart = draftStart ? (mapPoint.x - draftStart[0]) : 0;
                const dzStart = draftStart ? (mapPoint.z - draftStart[1]) : 0;
                const closeStart = draftStart && (dxStart * dxStart + dzStart * dzStart) <= getEditorHitRadius(14) * getEditorHitRadius(14);
                if (closeStart) {
                  editorState.previewPoint = [draftStart[0], draftStart[1]];
                } else if (vertexHit) {
                  editorState.previewPoint = [vertexHit.point[0], vertexHit.point[1]];
                } else if (endpointHit) {
                  editorState.previewPoint = [endpointHit.point[0], endpointHit.point[1]];
                } else if (edgeHit) {
                  editorState.previewPoint = [edgeHit.point.x, edgeHit.point.z];
                } else {
                  editorState.previewPoint = [snapped.x, snapped.z];
                }
              } else {
                editorState.previewPoint = [snapped.x, snapped.z];
              }
            } else {
              editorState.previewPoint = null;
            }
            updateDraftLine();
          }
          updateEditorHover(snapped);
          return;
        }

        if (editorState.dragging.mode === 'draft') {
          const idx = editorState.dragging.index;
          if (editorState.draft[idx]) {
            editorState.draft[idx] = [snapped.x, snapped.z];
            updateDraftLine();
            updateDraftMarkers();
          }
          return;
        }

        if (!editorState.selected) return;
        const { layer, index, vertexIndex } = editorState.selected;
        const list = blueprintData?.[layer];
        if (!list || !list[index]) return;
        const entry = list[index];

        if (editorState.dragging.mode === 'vertex' && vertexIndex !== null) {
          let target = snapped;
          if (entry.polyline) {
            const endpointHit = findNearestLineEndpoint(mapPoint, getEditorHitRadius(14));
            if (endpointHit &&
              !(endpointHit.index === index && endpointHit.vertexIndex === vertexIndex)) {
              target = { x: endpointHit.point[0], z: endpointHit.point[1] };
            }
          }
          if (entry.polyline) {
            entry.polyline[vertexIndex] = [target.x, target.z];
          } else if (entry.polygon) {
            entry.polygon[vertexIndex] = [target.x, target.z];
          }
          editorState.dragging.didMove = true;
        } else if (editorState.dragging.mode === 'polygon' && editorState.dragging.original) {
          const dx = snapped.x - editorState.dragging.start.x;
          const dz = snapped.z - editorState.dragging.start.z;
          const moved = editorState.dragging.original.map(p => [p[0] + dx, p[1] + dz]);
          if (editorState.dragging.isPolyline) {
            entry.polyline = moved;
          } else {
            entry.polygon = moved;
            if (Array.isArray(entry.curves)) {
              entry.curves = editorState.dragging.curves || entry.curves;
            }
          }
          editorState.dragging.didMove = true;
        }
        scheduleEditorRebuild();
      });

      renderer.domElement.addEventListener('pointerup', (e) => {
        if (e.pointerType === 'touch') {
          panState.touchPoints.delete(e.pointerId);
          if (panState.touchPoints.size < 2) {
            panState.active = false;
            panState.isTouch = false;
          }
        }
        if (panState.pending && e.pointerId === panState.pointerId) {
          panState.pending = false;
          panState.active = false;
          panState.pointerId = null;
          const deferred = panState.deferredAction;
          panState.deferredAction = null;
          if (deferred) {
            handleEditorPointerDown(deferred.snapped, deferred.mapPoint, deferred.mode, deferred.doubleClick);
          }
        }
        if (panState.active && !panState.isTouch && e.pointerId === panState.pointerId) {
          panState.active = false;
          panState.pointerId = null;
        }
        if (editorState.dragging?.historySnapshot &&
          editorState.dragging.didMove &&
          !editorState.dragging.historyPushed) {
          pushEditorHistory(editorState.dragging.historySnapshot);
        }
        if (editorState.dragging?.didMove) {
          scheduleEditorRebuild();
        }
        editorState.dragging = null;
      });

      renderer.domElement.addEventListener('pointercancel', (e) => {
        if (e.pointerType === 'touch') {
          panState.touchPoints.delete(e.pointerId);
          if (panState.touchPoints.size < 2) {
            panState.active = false;
            panState.isTouch = false;
          }
        }
        if (panState.pointerId === e.pointerId) {
          panState.pending = false;
          panState.active = false;
          panState.pointerId = null;
          panState.deferredAction = null;
        }
      });

      window.addEventListener('keydown', (e) => {
        if (!editorActive()) return;
        const activeEl = document.activeElement;
        const isTextInput = activeEl &&
          (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA' || activeEl.isContentEditable);
        if (!isTextInput && (e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
          e.preventDefault();
          if (e.shiftKey) {
            redoEditor();
          } else {
            undoEditor();
          }
          return;
        }
        if (!isTextInput && (e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'y') {
          e.preventDefault();
          redoEditor();
          return;
        }
        if (e.key === 'Enter') {
          if (editorState.tool === 'polygon') addPolygonFromDraft();
          if (editorState.tool === 'polyline') addPolylineFromDraft();
        } else if (e.key === 'Escape') {
          editorState.draft = [];
          editorState.previewPoint = null;
          clearJunctionMode();
          updateDraftLine();
          updateDraftMarkers();
          updateEditorStatus('Draft cancelled.');
        } else if (e.key === 'Delete' || e.key === 'Backspace') {
          const mode = getEditorMode();
          if (mode === 'draw-polygon' || mode === 'draw-polyline') {
            if (editorState.draft.length > 0) {
              if (editorState.hoverDraftIndex !== null) {
                editorState.draft.splice(editorState.hoverDraftIndex, 1);
                editorState.hoverDraftIndex = null;
              } else {
                editorState.draft.pop();
              }
              editorState.previewPoint = null;
              if (editorState.draft.length === 0) {
                clearJunctionMode();
              }
              updateDraftLine();
              updateDraftMarkers();
              updateEditorStatus(`Draft points: ${editorState.draft.length}`);
            }
          } else {
            deleteSelection();
          }
        }
      });
    }
    
    // ============================================
// ANIMATION LOOP
    // ============================================
    
    const renderLoop = createRenderLoop({
      renderer,
      scene,
      cameras: {
        perspCamera,
        getActiveCamera: () => activeCamera
      },
      controls,
      getViewMode: () => viewMode,
      getAnimationEnabled: () => animationEnabled,
      renderFps: RENDER_FPS,
      keyState,
      animateWater,
      animateCars,
      animateBlueprintTraffic,
      getWindmillsGroup: () => windmillsGroup,
      getFerrisWheelRef: () => ferrisWheelRef,
      warningLights,
      marqueeLights,
      getPerfLogging: () => PERF_LOGGING
    });
    
    // Start
    init();
    renderLoop.start();
    
  </script>
</body>
</html>
